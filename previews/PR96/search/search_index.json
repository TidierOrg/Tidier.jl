{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierjl","title":"What is Tidier.jl?","text":"<p>Tidier.jl is a 100% Julia implementation of the R tidyverse mini-language in Julia. Powered by the DataFrames.jl package and Julia\u2019s extensive meta-programming capabilities, Tidier.jl is an R user\u2019s love letter to data analysis in Julia.</p> <p><code>Tidier.jl</code> has three goals, which differentiate it from other data analysis meta-packages in Julia:</p> Stick as closely to tidyverse syntax as possible. <p>Whereas other meta-packages introduce Julia-centric idioms for working with DataFrames, this package\u2019s goal is to reimplement parts of tidyverse in Julia. This means that <code>Tidier.jl</code> uses tidy expressions as opposed to idiomatic Julia expressions. An example of a tidy expression is <code>a = mean(b)</code>. In Julia, <code>a</code> and <code>b</code> are variables and are thus \"eagerly\" evaluated. This means that if <code>b</code> is merely referring to a column in a data frame and not an object in the global namespace, then an error will be generated because <code>b</code> was not found. In idiomatic Julia, <code>b</code> would need to be expressed as a symbol, or <code>:b</code>. Even then, <code>a = mean(:b)</code> would generate an error because it's not possible to calculate the mean value of a symbol. To handle this using idiomatic Julia, <code>DataFrames.jl</code> introduces a mini-language that relies heavily on the creation of anonymous functions, with explicit directional pairs syntax using a <code>source =&gt; function =&gt; destination</code> syntax. While this is quite elegant, it can be verbose. <code>Tidier.jl</code> aims to reduce this complexity by exposing an R-like syntax, which is then converted into valid <code>DataFrames.jl</code> code. The reason that tidy expressions are considered valid by Julia in <code>Tidier.jl</code> is because they are implemented using macros. Macros \"capture\" the expressions they are given, and then they can modify those expressions before evaluating them. For consistency, all top-level <code>dplyr</code> functions are implemented as macros (whether or not a macro is truly needed), and all \"helper\" functions (used inside of those top-level functions) are implemented as functions or pseudo-functions (functions which only exist through modification of the abstract syntax tree).</p> Make broadcasting mostly invisible. <p>Broadcasting trips up many R users switching to Julia because R users are used to most functions being vectorized. <code>Tidier.jl</code> currently uses a lookup table to decide which functions not to vectorize; all other functions are automatically vectorized. Read the documentation page on \"Autovectorization\" to read about how this works, and how to override the defaults. An example of where this issue commonly causes errors is when centering a variable. To create a new column <code>a</code> that centers the column <code>b</code>, <code>Tidier.jl</code> lets you simply write <code>a = b - mean(b)</code> exactly as you would in R. This works because <code>Tidier.jl</code> knows to not vectorize <code>mean()</code> while also recognizing that <code>-</code> should be vectorized such that this expression is rewritten in <code>DataFrames.jl</code> as <code>:b =&gt; (b -&gt; b .- mean(b)) =&gt; :a</code>. For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a <code>~</code>. For example, a function <code>new_mean()</code>, if it had the same functionality as <code>mean()</code> would normally get vectorized by <code>Tidier.jl</code> unless you write it as <code>~new_mean()</code>.</p> Make scalars and tuples mostly interchangeable. <p>In Julia, the function <code>across(a, mean)</code> is dispatched differently than <code>across((a, b), mean)</code>. The first argument in the first instance above is treated as a scalar, whereas the second instance is treated as a tuple. This can be very confusing to R users because <code>1 == c(1)</code> is <code>TRUE</code> in R, whereas in Julia <code>1 == (1,)</code> evaluates to <code>false</code>. The design philosophy in <code>Tidier.jl</code> is that the user should feel free to provide a scalar or a tuple as they see fit anytime multiple values are considered valid for a given argument, such as in <code>across()</code>, and <code>Tidier.jl</code> will figure out how to dispatch it.</p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add Tidier\n</code></pre> <p>The <code>]</code> character starts the Julia package manager. Press the backspace key to return to the Julia prompt.</p> <p>or</p> <pre><code>using Pkg\nPkg.add(\"Tidier\")\n</code></pre> <p>For the newest version:</p> <pre><code>] add Tidier#main\n</code></pre> <p>or</p> <pre><code>using Pkg\nPkg.add(url=\"https://github.com/TidierOrg/Tidier.jl\")\n</code></pre> <p></p> <p></p>"},{"location":"#what-macros-and-functions-does-tidierjl-support","title":"What macros and functions does Tidier.jl support?","text":"<p>To support R-style programming, <code>Tidier.jl</code> is implemented using macros. This is because macros are able to \"capture\" the code before executing it, which allows the package to support R-like \"tidy expressions\" that would otherwise not be considered valid Julia code.</p> <p>Tidier.jl currently supports the following top-level macros:</p> <p>Top-level macros:</p> <ul> <li><code>@glimpse()</code></li> <li><code>@select()</code>, <code>@rename()</code>, and <code>@distinct()</code></li> <li><code>@mutate()</code> and <code>@transmute()</code> </li> <li><code>@summarize()</code> and <code>@summarise()</code></li> <li><code>@filter()</code> and <code>@slice()</code></li> <li><code>@group_by()</code> and <code>@ungroup()</code></li> <li><code>@arrange()</code></li> <li><code>@pull()</code></li> <li><code>@count()</code> and <code>@tally()</code></li> <li><code>@left_join()</code>, <code>@right_join()</code>, <code>@inner_join()</code>, and <code>@full_join()</code></li> <li><code>@bind_rows()</code> and <code>@bind_cols()</code></li> <li><code>@pivot_wider()</code> and <code>@pivot_longer()</code></li> <li><code>@drop_na()</code></li> <li><code>@clean_names()</code> (as in R's <code>janitor::clean_names()</code> function)</li> </ul> <p>Tidier.jl also supports the following helper functions:</p> <p>Helper functions:</p> <ul> <li><code>across()</code></li> <li><code>desc()</code></li> <li><code>if_else()</code> and <code>case_when()</code></li> <li><code>n()</code> and <code>row_number()</code></li> <li><code>ntile()</code></li> <li><code>lag()</code> and <code>lead()</code></li> <li><code>starts_with()</code>, <code>ends_with()</code>, <code>matches()</code>, and <code>contains()</code></li> <li><code>as_float()</code>, <code>as_integer()</code>, and <code>as_string()</code></li> </ul> <p>See the Reference page for a detailed guide to each of the macros and functions.</p> <p></p> <p></p>"},{"location":"#example","title":"Example","text":"<p>Let's select the first five movies in our dataset whose budget exceeds the mean budget. Unlike in R, where we pass an <code>na.rm = TRUE</code> argument to remove missing values, in Julia we wrap the variable with a <code>skipmissing()</code> to remove the missing values before the <code>mean()</code> is calculated.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n\n@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@filter(Budget &gt;= mean(skipmissing(Budget)))\n@select(Title, Budget)\n@slice(1:5)\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 Title                       Budget   \n     \u2502 String                      Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 'Til There Was You              23.0\n   2 \u2502 10 Things I Hate About You      16.0\n   3 \u2502 102 Dalmatians                  85.0\n   4 \u2502 13 Going On 30                  37.0\n   5 \u2502 13th Warrior, The               85.0\n</code></pre> <p></p> <p></p>"},{"location":"#whats-new","title":"What\u2019s new","text":"<p>See NEWS.md for the latest updates.</p> <p></p> <p></p>"},{"location":"#whats-missing","title":"What's missing","text":"<p>Is there a tidyverse feature missing that you would like to see in Tidier.jl? Please file a GitHub issue. Because Tidier.jl primarily wraps DataFrames.jl, our decision to integrate a new feature will be guided by how well-supported it is within DataFrames.jl and how likely other users are to benefit from it.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>Tidier.Tidier_set</code></li> <li><code>Tidier.across</code></li> <li><code>Tidier.as_float</code></li> <li><code>Tidier.as_integer</code></li> <li><code>Tidier.as_string</code></li> <li><code>Tidier.case_when</code></li> <li><code>Tidier.desc</code></li> <li><code>Tidier.if_else</code></li> <li><code>Tidier.n</code></li> <li><code>Tidier.ntile</code></li> <li><code>Tidier.row_number</code></li> <li><code>Tidier.@arrange</code></li> <li><code>Tidier.@bind_cols</code></li> <li><code>Tidier.@bind_rows</code></li> <li><code>Tidier.@count</code></li> <li><code>Tidier.@distinct</code></li> <li><code>Tidier.@drop_na</code></li> <li><code>Tidier.@filter</code></li> <li><code>Tidier.@full_join</code></li> <li><code>Tidier.@glimpse</code></li> <li><code>Tidier.@group_by</code></li> <li><code>Tidier.@inner_join</code></li> <li><code>Tidier.@left_join</code></li> <li><code>Tidier.@mutate</code></li> <li><code>Tidier.@pivot_longer</code></li> <li><code>Tidier.@pivot_wider</code></li> <li><code>Tidier.@pull</code></li> <li><code>Tidier.@rename</code></li> <li><code>Tidier.@right_join</code></li> <li><code>Tidier.@select</code></li> <li><code>Tidier.@slice</code></li> <li><code>Tidier.@summarise</code></li> <li><code>Tidier.@summarize</code></li> <li><code>Tidier.@tally</code></li> <li><code>Tidier.@transmute</code></li> <li><code>Tidier.@ungroup</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>Tidier.Tidier_set</code> \u2014 Method.</p> <pre><code>Tidier_set(option::AbstractString, value::Bool)\n</code></pre> <p>Set package options.</p> <p>Here are the supported options and what they do:</p> <ul> <li>\"code\": Defaults to <code>false</code>. If set to <code>true</code>, this option displays the DataFrames.jl code generated by the Tidier.jl package. It is useful for debugging whether errors are introduced by Tidier.jl's generated code.</li> </ul> <p>Arguments</p> <ul> <li><code>option</code>: \"code\"</li> <li><code>value</code>: <code>true</code> or <code>false</code></li> </ul> <p>source</p> <p># <code>Tidier.across</code> \u2014 Method.</p> <pre><code>across(variable[s], function[s])\n</code></pre> <p>Apply functions to multiple variables. If specifying multiple variables or functions, surround them with parentheses so that they are recognized as a tuple.</p> <p>This function should only be called inside of Tidier.jl macros.</p> <p>Arguments</p> <ul> <li><code>variable[s]</code>: An unquoted variable, or if multiple, an unquoted tuple of variables.</li> <li><code>function[s]</code>: A function, or if multiple, a tuple of functions.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@summarize(across(b, minimum))\nend\n1\u00d71 DataFrame\n Row \u2502 b_minimum \n     \u2502 Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502         1\n\njulia&gt; @chain df begin\n@summarize(across((b,c), (minimum, maximum)))\nend\n1\u00d74 DataFrame\n Row \u2502 b_minimum  c_minimum  b_maximum  c_maximum \n     \u2502 Int64      Int64      Int64      Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502         1         11          5         15\n\njulia&gt; @chain df begin\n@mutate(across((b,c), (minimum, maximum)))\nend\n5\u00d77 DataFrame\n Row \u2502 a     b      c      b_minimum  c_minimum  b_maximum  c_maximum \n     \u2502 Char  Int64  Int64  Int64      Int64      Int64      Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11          1         11          5         15\n   2 \u2502 b         2     12          1         11          5         15\n   3 \u2502 c         3     13          1         11          5         15\n   4 \u2502 d         4     14          1         11          5         15\n   5 \u2502 e         5     15          1         11          5         15\n\njulia&gt; @chain df begin\n@mutate(across((b, starts_with(\"c\")), (minimum, maximum)))\nend\n5\u00d77 DataFrame\n Row \u2502 a     b      c      b_minimum  c_minimum  b_maximum  c_maximum \n     \u2502 Char  Int64  Int64  Int64      Int64      Int64      Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11          1         11          5         15\n   2 \u2502 b         2     12          1         11          5         15\n   3 \u2502 c         3     13          1         11          5         15\n   4 \u2502 d         4     14          1         11          5         15\n   5 \u2502 e         5     15          1         11          5         15\n</code></pre> <p>source</p> <p># <code>Tidier.as_float</code> \u2014 Method.</p> <pre><code>as_float(value)\n</code></pre> <p>Convert a number or string to a Float64 data type.</p> <p>This is a useful helper for type conversions. Missing values are propagated.</p> <p>Arguments</p> <ul> <li><code>value</code>: An <code>AbstractString</code>, <code>Number</code>, or <code>missing</code> value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; as_float(1)\n1.0\n\njulia&gt; as_float(\"1.5\")\n1.5\n\njulia&gt; as_float(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>Tidier.as_integer</code> \u2014 Method.</p> <pre><code>as_integer(value)\n</code></pre> <p>Convert a number or string to an Int64 data type.</p> <p>This is a useful helper for type conversions. Missing values are propagated. Any values after the decimal point are removed.</p> <p>Arguments</p> <ul> <li><code>value</code>: An <code>AbstractString</code>, <code>Number</code>, or <code>missing</code> value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; as_integer(1)\n1\n\njulia&gt; as_integer(1.5)\n1\n\njulia&gt; as_integer(\"2\")\n2\n\njulia&gt; as_integer(\"2.5\")\n2\n\njulia&gt; as_integer(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>Tidier.as_string</code> \u2014 Method.</p> <pre><code>as_string(value)\n</code></pre> <p>Convert a number or string to a String data type.</p> <p>This is a useful helper for type conversions. Missing values are propagated.</p> <p>Arguments</p> <ul> <li><code>value</code>: An <code>AbstractString</code>, <code>Number</code>, or <code>missing</code> value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; as_string(1)\n\"1\"\n\njulia&gt; as_string(1.5)\n\"1.5\"\n\njulia&gt; as_string(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>Tidier.case_when</code> \u2014 Method.</p> <pre><code>case_when(condition =&gt; return_value)\ncase_when(condition_1 =&gt; return_value_1, condition_2 =&gt; return_value_2, ...)\n</code></pre> <p>Return the corresponding <code>return_value</code> for the first <code>condition</code> that evaluates to <code>true</code>.</p> <p>The most specific condition should be listed first and most general condition should be listed last. If none of the conditions evaluate to <code>true</code>, then a <code>missing</code> value is returned. </p> <p>Arguments</p> <ul> <li><code>condition</code>: A condition that evaluates to <code>true</code>, <code>false</code>, or <code>missing</code>.</li> <li><code>return_value</code>: The value to return if the condition is <code>true</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = [1, 2, missing, 4, 5]);\n\njulia&gt; @chain df begin\n@mutate(b = case_when(a &gt; 4  =&gt;  \"hi\",\na &gt; 2  =&gt;  \"medium\",\na &gt; 0  =&gt;  \"low\"))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1  low\n   2 \u2502       2  low\n   3 \u2502 missing  missing \n   4 \u2502       4  medium\n   5 \u2502       5  hi\n\njulia&gt; @chain df begin\n@mutate(b = case_when(a &gt; 4  =&gt;  \"hi\",\na &gt; 2  =&gt;  \"medium\",\na &gt; 0  =&gt;  \"low\",\ntrue   =&gt;  \"unknown\"))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   String  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1  low\n   2 \u2502       2  low\n   3 \u2502 missing  unknown\n   4 \u2502       4  medium\n   5 \u2502       5  hi\n\njulia&gt; @chain df begin\n@mutate(b = case_when(a &gt;= 3  =&gt;  3,\ntrue    =&gt;  a))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1        1\n   2 \u2502       2        2\n   3 \u2502 missing  missing \n   4 \u2502       4        3\n   5 \u2502       5        3\n\njulia&gt; @chain df begin\n@mutate(b = case_when(a &gt;= 3        =&gt;  3,\nismissing(a)  =&gt;  0,\ntrue          =&gt;  a))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b     \n     \u2502 Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1      1\n   2 \u2502       2      2\n   3 \u2502 missing      0\n   4 \u2502       4      3\n   5 \u2502       5      3\n</code></pre> <p>source</p> <p># <code>Tidier.desc</code> \u2014 Method.</p> <pre><code>desc(col)\n</code></pre> <p>Orders the rows of a DataFrame column in descending order when used inside of <code>@arrange()</code>. This function should only be called inside of `@arrange()``.</p> <p>Arguments</p> <ul> <li><code>col</code>: An unquoted column name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e', inner = 2), b = 1:10, c = 11:20);\n\njulia&gt; @chain df begin\n@arrange(a, desc(b))\nend\n10\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         2     12\n   2 \u2502 a         1     11\n   3 \u2502 b         4     14\n   4 \u2502 b         3     13\n   5 \u2502 c         6     16\n   6 \u2502 c         5     15\n   7 \u2502 d         8     18\n   8 \u2502 d         7     17\n   9 \u2502 e        10     20\n  10 \u2502 e         9     19\n</code></pre> <p>source</p> <p># <code>Tidier.if_else</code> \u2014 Method.</p> <pre><code>if_else(condition, yes, no, [miss])\n</code></pre> <p>Return the <code>yes</code> value if the <code>condition</code> is <code>true</code> and the <code>no</code> value if the <code>condition</code> is <code>false</code>. If <code>miss</code> is specified, then the provided <code>miss</code> value is returned when the <code>condition</code> contains a <code>missing</code> value. If <code>miss</code> is not specified, then the returned value is an explicit <code>missing</code> value.</p> <p>Arguments</p> <ul> <li><code>condition</code>: A condition that evaluates to <code>true</code>, <code>false</code>, or <code>missing</code>.</li> <li><code>yes</code>: Value to return if the condition is <code>true</code>.</li> <li><code>no</code>: Value to return if the condition is <code>false</code>.</li> <li><code>miss</code>: Optional. Value to return if the condition is <code>missing</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = [1, 2, missing, 4, 5]);\n\njulia&gt; @chain df begin\n@mutate(b = if_else(a &gt;= 3, \"yes\", \"no\"))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1  no\n   2 \u2502       2  no\n   3 \u2502 missing  missing \n   4 \u2502       4  yes\n   5 \u2502       5  yes\n\njulia&gt; @chain df begin\n@mutate(b = if_else(a &gt;= 3, \"yes\", \"no\", \"unknown\"))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   String  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1  no\n   2 \u2502       2  no\n   3 \u2502 missing  unknown\n   4 \u2502       4  yes\n   5 \u2502       5  yes\n\njulia&gt; @chain df begin\n@mutate(b = if_else(a &gt;= 3, 3, a))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1        1\n   2 \u2502       2        2\n   3 \u2502 missing  missing \n   4 \u2502       4        3\n   5 \u2502       5        3\n\njulia&gt; @chain df begin\n@mutate(b = if_else(a &gt;= 3, 3, a, 0))\nend\n5\u00d72 DataFrame\n Row \u2502 a        b     \n     \u2502 Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1      1\n   2 \u2502       2      2\n   3 \u2502 missing      0\n   4 \u2502       4      3\n   5 \u2502       5      3\n</code></pre> <p>source</p> <p># <code>Tidier.n</code> \u2014 Method.</p> <pre><code>n()\n</code></pre> <p>Return the number of rows in the DataFrame or in the group if used in the context of a GroupedDataFrame.</p> <p>Arguments</p> <ul> <li>None</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e', inner = 2), b = 1:10, c = 11:20);\n\njulia&gt; @chain df begin\n@summarize(n = n())\nend\n1\u00d71 DataFrame\n Row \u2502 n     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    10\n\njulia&gt; @chain df begin\n@group_by(a)\n@summarize(n = n())\nend\n5\u00d72 DataFrame\n Row \u2502 a     n     \n     \u2502 Char  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         2\n   2 \u2502 b         2\n   3 \u2502 c         2\n   4 \u2502 d         2\n   5 \u2502 e         2\n</code></pre> <p>source</p> <p># <code>Tidier.ntile</code> \u2014 Method.</p> <pre><code>ntile(x, n::Integer)\n</code></pre> <p>Break the input vector into <code>n</code> equal-sized buckets.</p> <p><code>ntile()</code> is a rough rank that breaks the input vector into <code>n</code> buckets. If <code>length(x)</code> is not an integer multiple of <code>n</code>, the size of the buckets will differ by up to one, with larger buckets coming first.</p> <p>Unlike other ranking functions, <code>ntile()</code> ignores ties: it will create evenly sized buckets even if the same value of <code>x</code> ends up in different buckets.</p> <p>Arguments</p> <ul> <li><code>x</code>: A vector to rank. By default, the smallest values will get the smallest ranks. Missing values will be given rank <code>missing</code>.</li> <li><code>n</code>: Number of groups to bucket into.</li> </ul> <p>Examples</p> <pre><code>julia&gt; x = [5,1,3,2,2, missing]\n6-element Vector{Union{Missing, Int64}}:\n 5\n 1\n 3\n 2\n 2\n  missing\n\njulia&gt; ntile(x, 2)\n6-element Vector{Union{Missing, Int64}}:\n 2\n 1\n 2\n 1\n 1\n  missing\n\njulia&gt; ntile(x, 4)\n6-element Vector{Union{Missing, Int64}}:\n 4\n 1\n 3\n 1\n 2\n  missing\n\njulia&gt; ntile(1:8, 3)\n8-element Vector{Int64}:\n 1\n 1\n 1\n 2\n 2\n 2\n 3\n 3\n\njulia&gt; df = DataFrame(a = 1:8);\n\njulia&gt; @chain df begin\n@mutate(buckets = ntile(a, 3))\nend\n8\u00d72 DataFrame\n Row \u2502 a      buckets \n     \u2502 Int64  Int64   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1\n   2 \u2502     2        1\n   3 \u2502     3        1\n   4 \u2502     4        2\n   5 \u2502     5        2\n   6 \u2502     6        2\n   7 \u2502     7        3\n   8 \u2502     8        3\n</code></pre> <p>source</p> <p># <code>Tidier.row_number</code> \u2014 Method.</p> <pre><code>row_number()\n</code></pre> <p>Return each row's number in a DataFrame or in the group if used in the context of a GroupedDataFrame.</p> <p>Arguments</p> <ul> <li>None</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e', inner = 2));\n\njulia&gt; @chain df begin\n@mutate(row_num = row_number())\nend\n10\u00d72 DataFrame\n Row \u2502 a     row_num \n     \u2502 Char  Int64   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1\n   2 \u2502 a           2\n   3 \u2502 b           3\n   4 \u2502 b           4\n   5 \u2502 c           5\n   6 \u2502 c           6\n   7 \u2502 d           7\n   8 \u2502 d           8\n   9 \u2502 e           9\n  10 \u2502 e          10\n\njulia&gt; @chain df begin\n@mutate(row_num = row_number() + 1)\nend\n10\u00d72 DataFrame\n Row \u2502 a     row_num \n     \u2502 Char  Int64   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           2\n   2 \u2502 a           3\n   3 \u2502 b           4\n   4 \u2502 b           5\n   5 \u2502 c           6\n   6 \u2502 c           7\n   7 \u2502 d           8\n   8 \u2502 d           9\n   9 \u2502 e          10\n  10 \u2502 e          11\n\njulia&gt; @chain df begin\n@filter(row_number() &lt;= 5)\nend\n5\u00d71 DataFrame\n Row \u2502 a    \n     \u2502 Char \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a\n   2 \u2502 a\n   3 \u2502 b\n   4 \u2502 b\n   5 \u2502 c\n</code></pre> <p>source</p> <p># <code>Tidier.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(df, exprs...)\n</code></pre> <p>Order the rows of a DataFrame by the values of specified columns.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: Variables from the input DataFrame. Use <code>desc()</code> to sort in descending order. Multiple variables can be specified, separated by commas.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e', inner = 2), b = 1:10, c = 11:20);\n\njulia&gt; @chain df begin\n@arrange(a)\nend\n10\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 a         2     12\n   3 \u2502 b         3     13\n   4 \u2502 b         4     14\n   5 \u2502 c         5     15\n   6 \u2502 c         6     16\n   7 \u2502 d         7     17\n   8 \u2502 d         8     18\n   9 \u2502 e         9     19\n  10 \u2502 e        10     20\n\njulia&gt; @chain df begin\n@arrange(a, desc(b))\nend\n10\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         2     12\n   2 \u2502 a         1     11\n   3 \u2502 b         4     14\n   4 \u2502 b         3     13\n   5 \u2502 c         6     16\n   6 \u2502 c         5     15\n   7 \u2502 d         8     18\n   8 \u2502 d         7     17\n   9 \u2502 e        10     20\n  10 \u2502 e         9     19\n</code></pre> <p>source</p> <p># <code>Tidier.@bind_cols</code> \u2014 Macro.</p> <pre><code>@bind_cols(dfs...)\n</code></pre> <p>Bind many DataFrames into one by column. </p> <p>Arguments</p> <ul> <li><code>dfs...</code>: DataFrames to combine.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a=1:3, b=1:3);\n\njulia&gt; df2 = DataFrame(a=4:6, b=4:6);\n\njulia&gt; df3 = DataFrame(a=7:9, c=7:9);\n\njulia&gt; @chain df1 begin\n@bind_cols(df2, df3)\nend\n3\u00d76 DataFrame\n Row \u2502 a      b      a_1    b_1    a_2    c     \n     \u2502 Int64  Int64  Int64  Int64  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1      4      4      7      7\n   2 \u2502     2      2      5      5      8      8\n   3 \u2502     3      3      6      6      9      9\n</code></pre> <p>source</p> <p># <code>Tidier.@bind_rows</code> \u2014 Macro.</p> <pre><code>@bind_rows(dfs..., id)\n</code></pre> <p>Bind many DataFrames into one by row. </p> <p>Columns present in at least one of the provided DataFrames are kept. Columns not present in some DataFrames are filled with missing values where necessary.</p> <p>Arguments</p> <ul> <li><code>dfs...</code>: DataFrames to combine.</li> <li><code>id</code>: string DataFrame identifier. When id is supplied, a new column of numeric identifiers is created to link each row to its original DataFrame.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a=1:3, b=1:3);\n\njulia&gt; df2 = DataFrame(a=4:6, b=4:6);\n\njulia&gt; df3 = DataFrame(a=7:9, c=7:9);\n\njulia&gt; @chain df1 begin\n@bind_rows(df2)\nend\n6\u00d72 DataFrame\n Row \u2502 a      b     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1\n   2 \u2502     2      2\n   3 \u2502     3      3\n   4 \u2502     4      4\n   5 \u2502     5      5\n   6 \u2502     6      6\n</code></pre> <p>When columns are not present in some DataFrames, they are filled with missing values.</p> <pre><code>julia&gt; @chain df1 begin\n@bind_rows(df2, df3)\nend\n9\u00d73 DataFrame\n Row \u2502 a      b        c       \n     \u2502 Int64  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1  missing \n   2 \u2502     2        2  missing \n   3 \u2502     3        3  missing \n   4 \u2502     4        4  missing \n   5 \u2502     5        5  missing \n   6 \u2502     6        6  missing \n   7 \u2502     7  missing        7\n   8 \u2502     8  missing        8\n   9 \u2502     9  missing        9\n\njulia&gt; @chain df1 begin\n@bind_rows(df2, df3, id = \"id\")\nend\n9\u00d74 DataFrame\n Row \u2502 a      b        c        id    \n     \u2502 Int64  Int64?   Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1  missing      1\n   2 \u2502     2        2  missing      1\n   3 \u2502     3        3  missing      1\n   4 \u2502     4        4  missing      2\n   5 \u2502     5        5  missing      2\n   6 \u2502     6        6  missing      2\n   7 \u2502     7  missing        7      3\n   8 \u2502     8  missing        8      3\n   9 \u2502     9  missing        9      3\n</code></pre> <p>source</p> <p># <code>Tidier.@count</code> \u2014 Macro.</p> <pre><code>@count(df, exprs..., [wt], [sort])\n</code></pre> <p>Count the unique values of one or more variables, with an optional weighting.</p> <p><code>@chain df @count(a, b)</code> is roughly equivalent to <code>@chain df @group_by(a, b) @summarize(n = n())</code>. Supply <code>wt</code> to perform weighted counts, switching the summary from <code>n = n()</code> to <code>n = sum(wt)</code>. Note that if grouping columns are provided, the result will be an ungrouped data frame, which is slightly different behavior than R's <code>tidyverse</code>.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame or GroupedDataFrame.</li> <li><code>exprs...</code>: Column names, separated by commas.</li> <li><code>wt</code>: Optional parameter. Used to calculate a sum over the provided <code>wt</code> variable instead of counting the rows.</li> <li><code>sort</code>: Defaults to <code>false</code>. Whether the result should be sorted from highest to lowest <code>n</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = vcat(repeat([\"a\"], inner = 3),\nrepeat([\"b\"], inner = 3),\nrepeat([\"c\"], inner = 1),\nmissing),\nb = 1:8)\n8\u00d72 DataFrame\n Row \u2502 a        b     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            1\n   2 \u2502 a            2\n   3 \u2502 a            3\n   4 \u2502 b            4\n   5 \u2502 b            5\n   6 \u2502 b            6\n   7 \u2502 c            7\n   8 \u2502 missing      8\n\njulia&gt; @chain df begin\n@count()\nend\n1\u00d71 DataFrame\n Row \u2502 n     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     8\n\njulia&gt; @chain df begin\n@count(a)\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            3\n   2 \u2502 b            3\n   3 \u2502 c            1\n   4 \u2502 missing      1\n\njulia&gt; @chain df begin\n@count(a, wt = b)\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            6\n   2 \u2502 b           15\n   3 \u2502 c            7\n   4 \u2502 missing      8\n\njulia&gt; @chain df begin\n@count(a, wt = b, sort = true)\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 b           15\n   2 \u2502 missing      8\n   3 \u2502 c            7\n   4 \u2502 a            6       \n</code></pre> <p>source</p> <p># <code>Tidier.@distinct</code> \u2014 Macro.</p> <pre><code>distinct(df, exprs...)\n</code></pre> <p>Return distinct rows of a DataFrame.</p> <p>If no columns or expressions are provided, then unique rows across all columns are returned. Otherwise, unique rows are determined based on the columns or expressions provided, and then all columns are returned.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: One or more unquoted variable names separated by commas. Variable names         can also be used as their positions in the data, like <code>x:y</code>, to select         a range of variables.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e', inner = 2), b = 1:10, c = 11:20);\n\njulia&gt; @chain df begin\n@distinct()\nend\n10\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 a         2     12\n   3 \u2502 b         3     13\n   4 \u2502 b         4     14\n   5 \u2502 c         5     15\n   6 \u2502 c         6     16\n   7 \u2502 d         7     17\n   8 \u2502 d         8     18\n   9 \u2502 e         9     19\n  10 \u2502 e        10     20\n\njulia&gt; @chain df begin\n@distinct(a)\nend\n5\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         3     13\n   3 \u2502 c         5     15\n   4 \u2502 d         7     17\n   5 \u2502 e         9     19\n</code></pre> <p>source</p> <p># <code>Tidier.@drop_na</code> \u2014 Macro.</p> <pre><code>@drop_na(df, [cols...])\n</code></pre> <p>Drop all rows with missing values.</p> <p>When called without arguments, <code>@drop_na()</code> drops all rows with missing values in any column. If columns are provided as an optional argument, only missing values from named columns are considered when dropping rows.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame or GroupedDataFrame.</li> <li><code>cols...</code>: An optional column, or multiple columns separated by commas or specified using selection helpers.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(\na = [1, 2, missing, 4],\nb = [1, missing, 3, 4]\n)\n4\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1        1\n   2 \u2502       2  missing \n   3 \u2502 missing        3\n   4 \u2502       4        4\n\njulia&gt; @chain df @drop_na()\n2\u00d72 DataFrame\n Row \u2502 a      b     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1\n   2 \u2502     4      4\n\njulia&gt; @chain df @drop_na(a)\n3\u00d72 DataFrame\n Row \u2502 a      b       \n     \u2502 Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1\n   2 \u2502     2  missing \n   3 \u2502     4        4\n\njulia&gt; @chain df @drop_na(a, b)\n2\u00d72 DataFrame\n Row \u2502 a      b     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1\n   2 \u2502     4      4\n\njulia&gt; @chain df @drop_na(starts_with(\"a\"))\n3\u00d72 DataFrame\n Row \u2502 a      b       \n     \u2502 Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1\n   2 \u2502     2  missing \n   3 \u2502     4        4\n</code></pre> <p>source</p> <p># <code>Tidier.@filter</code> \u2014 Macro.</p> <pre><code>@filter(df, exprs...)\n</code></pre> <p>Subset a DataFrame and return a copy of DataFrame where specified conditions are satisfied.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: transformation(s) that produce vectors containing <code>true</code> or <code>false</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@filter(b &gt;= mean(b))\nend\n3\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 c         3     13\n   2 \u2502 d         4     14\n   3 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@filter(b &gt;= 3 &amp;&amp; c &gt;= 14)\nend\n2\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 d         4     14\n   2 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@filter(b in (1, 3))\nend\n2\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 c         3     13\n</code></pre> <p>source</p> <p># <code>Tidier.@full_join</code> \u2014 Macro.</p> <pre><code>@full_join(df1, df2, [by])\n</code></pre> <p>Perform a full join on <code>df1</code> and <code>df</code> with an optional <code>by</code>.</p> <p>Arguments</p> <ul> <li><code>df1</code>: A DataFrame.</li> <li><code>df2</code>: A DataFrame.</li> <li><code>by</code>: An optional column or tuple of columns. <code>by</code> supports interpolation of individual columns. If <code>by</code> is not supplied, then it will be inferred from shared names of columns between <code>df1</code> and <code>df2</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a = [\"a\", \"b\"], b = 1:2);\n\njulia&gt; df2 = DataFrame(a = [\"a\", \"c\"], c = 3:4);\n\njulia&gt; @full_join(df1, df2)\n3\u00d73 DataFrame\n Row \u2502 a       b        c       \n     \u2502 String  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1        3\n   2 \u2502 b             2  missing \n   3 \u2502 c       missing        4\n\njulia&gt; @full_join(df1, df2, a)\n3\u00d73 DataFrame\n Row \u2502 a       b        c       \n     \u2502 String  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1        3\n   2 \u2502 b             2  missing \n   3 \u2502 c       missing        4\n\njulia&gt; @full_join(df1, df2, a = a)\n3\u00d73 DataFrame\n Row \u2502 a       b        c       \n     \u2502 String  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1        3\n   2 \u2502 b             2  missing \n   3 \u2502 c       missing        4\n\njulia&gt; @full_join(df1, df2, \"a\")\n3\u00d73 DataFrame\n Row \u2502 a       b        c       \n     \u2502 String  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1        3\n   2 \u2502 b             2  missing \n   3 \u2502 c       missing        4\n\njulia&gt; @full_join(df1, df2, \"a\" = \"a\")\n3\u00d73 DataFrame\n Row \u2502 a       b        c       \n     \u2502 String  Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1        3\n   2 \u2502 b             2  missing \n   3 \u2502 c       missing        4\n</code></pre> <p>source</p> <p># <code>Tidier.@glimpse</code> \u2014 Macro.</p> <pre><code>@glimpse(df, width = 80)\n</code></pre> <p>Preview a DataFrame (or GroupedDataFrame).</p> <p>The <code>@glimpse</code> macro is used to preview a DataFrame or GroupedDataFrame. Each column is printed on a separate row, along with its data type and first few elements, with the output truncated based on the <code>width</code>.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame or GroupedDataFrame.</li> <li><code>width</code>: The width of the output, measured in the number of characters. Defaults to 80.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(\na = 1:100, b = 1:100, c = repeat([\"a\"], 100)\n);\n\njulia&gt; @chain df @glimpse\nRows: 100\nColumns: 3\n.a             Int64          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n.b             Int64          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n.c             String         a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a,\n\njulia&gt; @chain df begin\n@group_by(a)\n@glimpse()\nend\nRows: 100\nColumns: 3\nGroups: a [100]\n.a             Int64          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n.b             Int64          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n.c             String         a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a,\n</code></pre> <p>source</p> <p># <code>Tidier.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(df, exprs...)\n</code></pre> <p>Return a <code>GroupedDataFrame</code> where operations are performed by groups specified by unique  sets of <code>cols</code>.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: DataFrame columns to group by or tidy expressions. Can be a single tidy expression or multiple expressions separated by commas.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@group_by(a)\n@summarize(b = mean(b))\nend\n5\u00d72 DataFrame\n Row \u2502 a     b       \n     \u2502 Char  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1.0\n   2 \u2502 b         2.0\n   3 \u2502 c         3.0\n   4 \u2502 d         4.0\n   5 \u2502 e         5.0  \n\njulia&gt; @chain df begin\n@group_by(d = uppercase(a))\n@summarize(b = mean(b))\nend\n5\u00d72 DataFrame\n Row \u2502 d     b       \n     \u2502 Char  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 A         1.0\n   2 \u2502 B         2.0\n   3 \u2502 C         3.0\n   4 \u2502 D         4.0\n   5 \u2502 E         5.0\n</code></pre> <p>source</p> <p># <code>Tidier.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(df1, df2, [by])\n</code></pre> <p>Perform a inner join on <code>df1</code> and <code>df</code> with an optional <code>by</code>.</p> <p>Arguments</p> <ul> <li><code>df1</code>: A DataFrame.</li> <li><code>df2</code>: A DataFrame.</li> <li><code>by</code>: An optional column or tuple of columns. <code>by</code> supports interpolation of individual columns. If <code>by</code> is not supplied, then it will be inferred from shared names of columns between <code>df1</code> and <code>df2</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a = [\"a\", \"b\"], b = 1:2);\n\njulia&gt; df2 = DataFrame(a = [\"a\", \"c\"], c = 3:4);\n\njulia&gt; @inner_join(df1, df2)\n1\u00d73 DataFrame\n Row \u2502 a       b      c     \n     \u2502 String  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1      3\n\njulia&gt; @inner_join(df1, df2, a)\n1\u00d73 DataFrame\n Row \u2502 a       b      c     \n     \u2502 String  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1      3\n\njulia&gt; @inner_join(df1, df2, a = a)\n1\u00d73 DataFrame\n Row \u2502 a       b      c     \n     \u2502 String  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1      3\n\njulia&gt; @inner_join(df1, df2, \"a\")\n1\u00d73 DataFrame\n Row \u2502 a       b      c     \n     \u2502 String  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1      3\n\njulia&gt; @inner_join(df1, df2, \"a\" = \"a\")\n1\u00d73 DataFrame\n Row \u2502 a       b      c     \n     \u2502 String  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1      3\n</code></pre> <p>source</p> <p># <code>Tidier.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(df1, df2, [by])\n</code></pre> <p>Perform a left join on <code>df1</code> and <code>df</code> with an optional <code>by</code>.</p> <p>Arguments</p> <ul> <li><code>df1</code>: A DataFrame.</li> <li><code>df2</code>: A DataFrame.</li> <li><code>by</code>: An optional column or tuple of columns. <code>by</code> supports interpolation of individual columns. If <code>by</code> is not supplied, then it will be inferred from shared names of columns between <code>df1</code> and <code>df2</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a = [\"a\", \"b\"], b = 1:2);\n\njulia&gt; df2 = DataFrame(a = [\"a\", \"c\"], c = 3:4);\n\njulia&gt; @left_join(df1, df2)\n2\u00d73 DataFrame\n Row \u2502 a       b      c       \n     \u2502 String  Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1        3\n   2 \u2502 b           2  missing \n\njulia&gt; @left_join(df1, df2, a)\n2\u00d73 DataFrame\n Row \u2502 a       b      c       \n     \u2502 String  Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1        3\n   2 \u2502 b           2  missing\n\njulia&gt; @left_join(df1, df2, a = a)\n2\u00d73 DataFrame\n Row \u2502 a       b      c       \n     \u2502 String  Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1        3\n   2 \u2502 b           2  missing\n\njulia&gt; @left_join(df1, df2, \"a\")\n2\u00d73 DataFrame\n Row \u2502 a       b      c       \n     \u2502 String  Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1        3\n   2 \u2502 b           2  missing\n\njulia&gt; @left_join(df1, df2, \"a\" = \"a\")\n2\u00d73 DataFrame\n Row \u2502 a       b      c       \n     \u2502 String  Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a           1        3\n   2 \u2502 b           2  missing\n</code></pre> <p>source</p> <p># <code>Tidier.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(df, exprs...)\n</code></pre> <p>Create new columns as functions of existing columns. The results have the same number of rows as <code>df</code>.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: add new columns or replace values of existed columns using        <code>new_variable = values</code> syntax.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@mutate(d = b + c, b_minus_mean_b = b - mean(b))\nend\n5\u00d75 DataFrame\n Row \u2502 a     b      c      d      b_minus_mean_b \n     \u2502 Char  Int64  Int64  Int64  Float64        \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11     12            -2.0\n   2 \u2502 b         2     12     14            -1.0\n   3 \u2502 c         3     13     16             0.0\n   4 \u2502 d         4     14     18             1.0\n   5 \u2502 e         5     15     20             2.0\n\njulia&gt; @chain df begin\n@mutate(d = b in (1,3))\nend\n5\u00d74 DataFrame\n Row \u2502 a     b      c      d     \n     \u2502 Char  Int64  Int64  Bool  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11   true\n   2 \u2502 b         2     12  false\n   3 \u2502 c         3     13   true\n   4 \u2502 d         4     14  false\n   5 \u2502 e         5     15  false\n\njulia&gt; @chain df begin\n@mutate(across((b, c), mean))\nend\n5\u00d75 DataFrame\n Row \u2502 a     b      c      b_mean   c_mean  \n     \u2502 Char  Int64  Int64  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11      3.0     13.0\n   2 \u2502 b         2     12      3.0     13.0\n   3 \u2502 c         3     13      3.0     13.0\n   4 \u2502 d         4     14      3.0     13.0\n   5 \u2502 e         5     15      3.0     13.0\n\njulia&gt; @chain df begin\n@summarize(across(contains(\"b\"), mean))\nend\n1\u00d71 DataFrame\n Row \u2502 b_mean  \n     \u2502 Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0\n\njulia&gt; @chain df begin\n@summarize(across(-contains(\"a\"), mean))\nend\n1\u00d72 DataFrame\n Row \u2502 b_mean   c_mean  \n     \u2502 Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0     13.0\n</code></pre> <p>source</p> <p># <code>Tidier.@pivot_longer</code> \u2014 Macro.</p> <p>@pivotlonger(df, cols, [namesto], [values_to])</p> <p>Reshapes the DataFrame to make it longer, increasing the number of rows and reducing the number of columns.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>cols</code>: Columns to pivot into longer format. Multiple columns can be selected but providing tuples of columns is not yet supported.</li> <li><code>names_to</code>: Optional, defaults to <code>variable</code>. The name of the newly created column whose values will contain the input DataFrame's column names.</li> <li><code>values_to</code>: Optional, defaults to <code>value</code>. The name of the newly created column containing the input DataFrame's cell values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df_wide = DataFrame(id = [1, 2], A = [1, 3], B = [2, 4]);\n\njulia&gt; @pivot_longer(df_wide, A:B)\n4\u00d73 DataFrame\n Row \u2502 id     variable  value \n     \u2502 Int64  String    Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A             1\n   2 \u2502     2  A             3\n   3 \u2502     1  B             2\n   4 \u2502     2  B             4\n\njulia&gt; @pivot_longer(df_wide, -id)\n4\u00d73 DataFrame\n Row \u2502 id     variable  value \n     \u2502 Int64  String    Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A             1\n   2 \u2502     2  A             3\n   3 \u2502     1  B             2\n   4 \u2502     2  B             4\n\njulia&gt; @pivot_longer(df_wide, A:B, names_to = \"letter\", values_to = \"number\")\n4\u00d73 DataFrame\n Row \u2502 id     letter  number \n     \u2502 Int64  String  Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A            1\n   2 \u2502     2  A            3\n   3 \u2502     1  B            2\n   4 \u2502     2  B            4\n\njulia&gt; @pivot_longer(df_wide, A:B, names_to = letter, values_to = number)\n4\u00d73 DataFrame\n Row \u2502 id     letter  number \n     \u2502 Int64  String  Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A            1\n   2 \u2502     2  A            3\n   3 \u2502     1  B            2\n   4 \u2502     2  B            4\n\njulia&gt; @pivot_longer(df_wide, A:B, names_to = \"letter\")\n4\u00d73 DataFrame\n Row \u2502 id     letter  value \n     \u2502 Int64  String  Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A           1\n   2 \u2502     2  A           3\n   3 \u2502     1  B           2\n   4 \u2502     2  B           4\n</code></pre> <p>source</p> <p># <code>Tidier.@pivot_wider</code> \u2014 Macro.</p> <p>@pivotwider(df, namesfrom, values_from)</p> <p>Reshapes the DataFrame to make it wider, increasing the number of columns and reducing the number of rows.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>names_from</code>: The name of the column to get the name of the output columns from.</li> <li><code>values_from</code>: The name of the column to get the cell values from.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df_long = DataFrame(id = [1, 1, 2, 2],\nvariable = [\"A\", \"B\", \"A\", \"B\"],\nvalue = [1, 2, 3, 4]);\n\njulia&gt; df_long_missing = DataFrame(id = [1, 1, 2],\nvariable = [\"A\", \"B\", \"B\"],\nvalue = [1, 2, 4]);\n\njulia&gt; @pivot_wider(df_long, names_from = variable, values_from = value)\n2\u00d73 DataFrame\n Row \u2502 id     A       B      \n     \u2502 Int64  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1       1       2\n   2 \u2502     2       3       4\n\njulia&gt; @pivot_wider(df_long, names_from = \"variable\", values_from = \"value\")\n2\u00d73 DataFrame\n Row \u2502 id     A       B      \n     \u2502 Int64  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1       1       2\n   2 \u2502     2       3       4\n\njulia&gt; @pivot_wider(df_long_missing, names_from = variable, values_from = value, values_fill = 0)\n2\u00d73 DataFrame\n Row \u2502 id     A      B     \n     \u2502 Int64  Int64  Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1      2\n   2 \u2502     2      0      4\n</code></pre> <p>source</p> <p># <code>Tidier.@pull</code> \u2014 Macro.</p> <pre><code>@pull(df, column)\n</code></pre> <p>Pull (or extract) a column as a vector.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>column</code>: A single column, referred to either by its name or number.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = 'a':'e', b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@pull(a)\nend\n5-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\njulia&gt; @chain df begin\n@pull(2)\nend\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n</code></pre> <p>source</p> <p># <code>Tidier.@rename</code> \u2014 Macro.</p> <pre><code>@rename(df, exprs...)\n</code></pre> <p>Change the names of individual column names in a DataFrame. Users can also use <code>@select()</code> to rename and select columns.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: Use <code>new_name = old_name</code> syntax to rename selected columns.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@rename(d = b, e = c)\nend\n5\u00d73 DataFrame\n Row \u2502 a     d      e     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         2     12\n   3 \u2502 c         3     13\n   4 \u2502 d         4     14\n   5 \u2502 e         5     15\n</code></pre> <p>source</p> <p># <code>Tidier.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(df1, df2, [by])\n</code></pre> <p>Perform a right join on <code>df1</code> and <code>df</code> with an optional <code>by</code>.</p> <p>Arguments</p> <ul> <li><code>df1</code>: A DataFrame.</li> <li><code>df2</code>: A DataFrame.</li> <li><code>by</code>: An optional column or tuple of columns. <code>by</code> supports interpolation of individual columns. If <code>by</code> is not supplied, then it will be inferred from shared names of columns between <code>df1</code> and <code>df2</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df1 = DataFrame(a = [\"a\", \"b\"], b = 1:2);\n\njulia&gt; df2 = DataFrame(a = [\"a\", \"c\"], c = 3:4);\n\njulia&gt; @right_join(df1, df2)\n2\u00d73 DataFrame\n Row \u2502 a       b        c     \n     \u2502 String  Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1      3\n   2 \u2502 c       missing      4\n\njulia&gt; @right_join(df1, df2, a)\n2\u00d73 DataFrame\n Row \u2502 a       b        c     \n     \u2502 String  Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1      3\n   2 \u2502 c       missing      4\n\njulia&gt; @right_join(df1, df2, a = a)\n2\u00d73 DataFrame\n Row \u2502 a       b        c     \n     \u2502 String  Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1      3\n   2 \u2502 c       missing      4\n\njulia&gt; @right_join(df1, df2, \"a\")\n2\u00d73 DataFrame\n Row \u2502 a       b        c     \n     \u2502 String  Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1      3\n   2 \u2502 c       missing      4\n\njulia&gt; @right_join(df1, df2, \"a\" = \"a\")\n2\u00d73 DataFrame\n Row \u2502 a       b        c     \n     \u2502 String  Int64?   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a             1      3\n   2 \u2502 c       missing      4\n</code></pre> <p>source</p> <p># <code>Tidier.@select</code> \u2014 Macro.</p> <pre><code>@select(df, exprs...)\n</code></pre> <p>Select variables in a DataFrame.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: One or more unquoted variable names separated by commas. Variable names         can also be used as their positions in the data, like <code>x:y</code>, to select         a range of variables.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@select(a, b, c)\nend\n5\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         2     12\n   3 \u2502 c         3     13\n   4 \u2502 d         4     14\n   5 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@select(a:b)\nend\n5\u00d72 DataFrame\n Row \u2502 a     b     \n     \u2502 Char  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1\n   2 \u2502 b         2\n   3 \u2502 c         3\n   4 \u2502 d         4\n   5 \u2502 e         5\n\njulia&gt; @chain df begin\n@select(1:2)\nend\n5\u00d72 DataFrame\n Row \u2502 a     b     \n     \u2502 Char  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1\n   2 \u2502 b         2\n   3 \u2502 c         3\n   4 \u2502 d         4\n   5 \u2502 e         5\n\njulia&gt; @chain df begin\n@select(-(a:b))\nend\n5\u00d71 DataFrame\n Row \u2502 c     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    11\n   2 \u2502    12\n   3 \u2502    13\n   4 \u2502    14\n   5 \u2502    15\n\njulia&gt; @chain df begin\n@select(!(a:b))\nend\n5\u00d71 DataFrame\n Row \u2502 c     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    11\n   2 \u2502    12\n   3 \u2502    13\n   4 \u2502    14\n   5 \u2502    15\n\njulia&gt; @chain df begin\n@select(contains(\"b\"), starts_with(\"c\"))\nend\n5\u00d72 DataFrame\n Row \u2502 b      c     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     11\n   2 \u2502     2     12\n   3 \u2502     3     13\n   4 \u2502     4     14\n   5 \u2502     5     15\n\njulia&gt; @chain df begin\n@select(-(1:2))\nend\n5\u00d71 DataFrame\n Row \u2502 c     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    11\n   2 \u2502    12\n   3 \u2502    13\n   4 \u2502    14\n   5 \u2502    15\n\njulia&gt; @chain df begin\n@select(!(1:2))\nend\n5\u00d71 DataFrame\n Row \u2502 c     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    11\n   2 \u2502    12\n   3 \u2502    13\n   4 \u2502    14\n   5 \u2502    15\n\njulia&gt; @chain df begin\n@select(-c)\nend\n5\u00d72 DataFrame\n Row \u2502 a     b     \n     \u2502 Char  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1\n   2 \u2502 b         2\n   3 \u2502 c         3\n   4 \u2502 d         4\n   5 \u2502 e         5\n\njulia&gt; @chain df begin\n@select(-contains(\"a\"))\nend\n5\u00d72 DataFrame\n Row \u2502 b      c     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     11\n   2 \u2502     2     12\n   3 \u2502     3     13\n   4 \u2502     4     14\n   5 \u2502     5     15\n\njulia&gt; @chain df begin\n@select(!contains(\"a\"))\nend\n5\u00d72 DataFrame\n Row \u2502 b      c     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     11\n   2 \u2502     2     12\n   3 \u2502     3     13\n   4 \u2502     4     14\n   5 \u2502     5     15\n</code></pre> <p>source</p> <p># <code>Tidier.@slice</code> \u2014 Macro.</p> <pre><code>@slice(df, exprs...)\n</code></pre> <p>Select, remove or duplicate rows by indexing their integer positions.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: integer row values. Use positive values to keep the rows, or negative values to drop. Values provided must be either all positive or all negative, and they must be within the range of DataFrames' row numbers.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@slice(1:5)\nend\n5\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         2     12\n   3 \u2502 c         3     13\n   4 \u2502 d         4     14\n   5 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@slice(-(1:2))\nend\n3\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 c         3     13\n   2 \u2502 d         4     14\n   3 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@group_by(a)\n@slice(1)\n@ungroup\nend\n5\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         2     12\n   3 \u2502 c         3     13\n   4 \u2502 d         4     14\n   5 \u2502 e         5     15\n</code></pre> <p>source</p> <p># <code>Tidier.@summarise</code> \u2014 Macro.</p> <pre><code>@summarize(df, exprs...)\n@summarise(df, exprs...)\n</code></pre> <p>Create a new DataFrame with one row that aggregating all observations from the input DataFrame or GroupedDataFrame. </p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: a <code>new_variable = function(old_variable)</code> pair. <code>function()</code> should be an aggregate function that returns a single value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@summarize(mean_b = mean(b), median_b = median(b))\nend\n1\u00d72 DataFrame\n Row \u2502 mean_b   median_b \n     \u2502 Float64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0       3.0\n\njulia&gt; @chain df begin\n@summarise(mean_b = mean(b), median_b = median(b))\nend\n1\u00d72 DataFrame\n Row \u2502 mean_b   median_b \n     \u2502 Float64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0       3.0\n\njulia&gt; @chain df begin\n@summarize(across((b,c), (minimum, maximum)))\nend\n1\u00d74 DataFrame\n Row \u2502 b_minimum  c_minimum  b_maximum  c_maximum \n     \u2502 Int64      Int64      Int64      Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502         1         11          5         15\n</code></pre> <p>source</p> <p># <code>Tidier.@summarize</code> \u2014 Macro.</p> <pre><code>@summarize(df, exprs...)\n@summarise(df, exprs...)\n</code></pre> <p>Create a new DataFrame with one row that aggregating all observations from the input DataFrame or GroupedDataFrame. </p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: a <code>new_variable = function(old_variable)</code> pair. <code>function()</code> should be an aggregate function that returns a single value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@summarize(mean_b = mean(b), median_b = median(b))\nend\n1\u00d72 DataFrame\n Row \u2502 mean_b   median_b \n     \u2502 Float64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0       3.0\n\njulia&gt; @chain df begin\n@summarise(mean_b = mean(b), median_b = median(b))\nend\n1\u00d72 DataFrame\n Row \u2502 mean_b   median_b \n     \u2502 Float64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3.0       3.0\n\njulia&gt; @chain df begin\n@summarize(across((b,c), (minimum, maximum)))\nend\n1\u00d74 DataFrame\n Row \u2502 b_minimum  c_minimum  b_maximum  c_maximum \n     \u2502 Int64      Int64      Int64      Int64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502         1         11          5         15\n</code></pre> <p>source</p> <p># <code>Tidier.@tally</code> \u2014 Macro.</p> <pre><code>@tally(df, [wt], [sort])\n</code></pre> <p>Tally the unique values of one or more variables, with an optional weighting.</p> <p><code>@tally()</code> is a low-level helper macro for <code>@count()</code> that assumes that any grouping has already been performed. <code>@chain @tally()</code> is roughly equivalent to <code>@chain df @summarize(n = n())</code>. Supply <code>wt</code> to perform weighted counts, switching the summary from <code>n = n()</code> to <code>n = sum(wt)</code>.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame or GroupedDataFrame.</li> <li><code>wt</code>: Optional parameter. Used to calculate a sum over the provided <code>wt</code> variable instead of counting the rows.</li> <li><code>sort</code>: Defaults to <code>false</code>. Whether the result should be sorted from highest to lowest <code>n</code>.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = vcat(repeat([\"a\"], inner = 3),\nrepeat([\"b\"], inner = 3),\nrepeat([\"c\"], inner = 1),\nmissing),\nb = 1:8)\n8\u00d72 DataFrame\n Row \u2502 a        b     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            1\n   2 \u2502 a            2\n   3 \u2502 a            3\n   4 \u2502 b            4\n   5 \u2502 b            5\n   6 \u2502 b            6\n   7 \u2502 c            7\n   8 \u2502 missing      8\n\njulia&gt; @chain df begin\n@tally()\nend\n1\u00d71 DataFrame\n Row \u2502 n     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     8\n\njulia&gt; @chain df begin\n@group_by(a)\n@tally()\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            3\n   2 \u2502 b            3\n   3 \u2502 c            1\n   4 \u2502 missing      1\n\njulia&gt; @chain df begin\n@group_by(a)\n@tally(wt = b)\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a            6\n   2 \u2502 b           15\n   3 \u2502 c            7\n   4 \u2502 missing      8\n\njulia&gt; @chain df begin\n@group_by(a)\n@tally(wt = b, sort = true)\nend\n4\u00d72 DataFrame\n Row \u2502 a        n     \n     \u2502 String?  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 b           15\n   2 \u2502 missing      8\n   3 \u2502 c            7\n   4 \u2502 a            6       \n</code></pre> <p>source</p> <p># <code>Tidier.@transmute</code> \u2014 Macro.</p> <pre><code>@transmute(df, exprs...)\n</code></pre> <p>Create a new DataFrame with only computed columns.</p> <p>Arguments</p> <ul> <li><code>df</code>: A DataFrame.</li> <li><code>exprs...</code>: add new columns or replace values of existed columns using        <code>new_variable = values</code> syntax.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@transmute(d = b + c)\nend\n5\u00d71 DataFrame\n Row \u2502 d     \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502    12\n   2 \u2502    14\n   3 \u2502    16\n   4 \u2502    18\n   5 \u2502    20\n</code></pre> <p>source</p> <p># <code>Tidier.@ungroup</code> \u2014 Macro.</p> <pre><code>@ungroup(df)\n</code></pre> <p>Return a <code>DataFrame</code> with all groups removed.</p> <p>If this is applied to a <code>GroupedDataFrame</code>, then it removes the grouping. If this is applied to a <code>DataFrame</code> (without any groups), then it returns the <code>DataFrame</code> unchanged.</p> <p>Arguments</p> <ul> <li><code>df</code>: A <code>GroupedDataFrame</code> or `DataFrame``.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(a = repeat('a':'e'), b = 1:5, c = 11:15);\n\njulia&gt; @chain df begin\n@group_by(a)\nend\nGroupedDataFrame with 5 groups based on key: a\nFirst Group (1 row): a = 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n\u22ee\nLast Group (1 row): a = 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 e         5     15\n\njulia&gt; @chain df begin\n@group_by(a)\n@ungroup\nend\n5\u00d73 DataFrame\n Row \u2502 a     b      c     \n     \u2502 Char  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 a         1     11\n   2 \u2502 b         2     12\n   3 \u2502 c         3     13\n   4 \u2502 d         4     14\n   5 \u2502 e         5     15\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/Contributors/Howto/","title":"Contribute","text":""},{"location":"examples/generated/Contributors/Howto/#contribute-to-documentation","title":"Contribute to Documentation","text":"<p>Contributing with examples can be done by first creating a new file example here</p> <p>Info</p> <ul> <li><code>your_new_file.jl</code> at <code>docs/examples/UserGuide/</code></li> </ul> <p>Once this is done you need to add a new entry here at the bottom and the appropriate level.</p> <p>Info</p> <p>Your new entry should look like:</p> <ul> <li><code>\"Your title example\" : \"examples/generated/UserGuide/your_new_file.md\"</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/Contributors/Howto/#build-docs-locally","title":"Build docs locally","text":"<p>If you want to take a look at the docs locally before doing a PR follow the next steps:</p> <p>build docs locally</p> <p>Install the following dependencies in your system via pip, i.e.</p> <ul> <li><code>pip install mkdocs pygments python-markdown-math</code></li> <li><code>pip install mkdocs-material pymdown-extensions mkdocstrings</code></li> <li><code>pip mknotebooks pytkdocs_tweaks mkdocs_include_exclude_files jinja2 mkdocs-video</code></li> </ul> <p>Then simply go to your <code>docs</code> env and activate it, i.e.</p> <p><code>docs&gt; julia</code></p> <p><code>julia&gt; ]</code></p> <p><code>(docs) pkg&gt; activate .</code></p> <p>Next, run the scripts:</p> <p>Info</p> <p>Generate files and build docs by running:</p> <ul> <li><code>genfiles.jl</code></li> <li><code>make.jl</code></li> </ul> <p>Now go to your <code>terminal</code> in the same path <code>docs&gt;</code> and run:</p> <p><code>mkdocs serve</code></p> <p>This should output <code>http://127.0.0.1:8000</code>, copy/paste this into your browser and you are all set.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/across/","title":"across","text":"<p><code>across()</code> is a helper function that is typically used inside <code>@mutate()</code> or <code>@summarize</code> to operate on multiple columns and/or multiple functions. Notice that <code>across()</code> accepts two arguments, a set of variables and a set of functions. If providing multiple variables or functions, these should be provided as a tuple \u2013 in other words, wrapped in parentheses and separated by commas. If you want to skip missing values, you can \"fuse\" the summary function (such as <code>mean()</code>) with the <code>skipmissing()</code> function by using the fuction fusion operator, which you can type out in Julia by typing <code>\\circ</code> and then pressing <code>[Tab]</code> such that it reads <code>mean\u2218skipmissing</code>.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/across/#one-variable-one-function","title":"One variable, one function","text":"<pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@summarize(across(Budget, mean\u2218skipmissing))\nend\n</code></pre> 1\u00d71 DataFrame RowBudget_mean_skipmissingFloat64113.4125"},{"location":"examples/generated/UserGuide/across/#one-variable-one-anonymous-function","title":"One variable, one anonymous function","text":"<pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@summarize(across(Budget, (x -&gt; mean(skipmissing(x)))))\nend\n</code></pre> 1\u00d71 DataFrame RowBudget_functionFloat64113.4125 <p>Note: compound functions are not correctly supported inside of anonymous functions. As of right now, the above function works, but <code>(x -&gt; mean\u2218skipmissing(x))</code> does not work. This is a known bug and will be fixed in a future update.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/across/#multiple-variables-multiple-functions","title":"Multiple variables, multiple functions","text":"<pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@summarize(across((Rating, Budget), (mean\u2218skipmissing, median\u2218skipmissing)))\nend\n</code></pre> 1\u00d74 DataFrame RowRating_mean_skipmissingBudget_mean_skipmissingRating_median_skipmissingBudget_median_skipmissingFloat64Float64Float64Float6415.9328513.41256.13.0"},{"location":"examples/generated/UserGuide/across/#multiple-selection-helpers-multiple-functions","title":"Multiple selection helpers, multiple functions","text":"<pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@summarize(across((starts_with(\"Bud\"), ends_with(\"ting\")), (mean\u2218skipmissing, median\u2218skipmissing)))\nend\n</code></pre> 1\u00d74 DataFrame RowBudget_mean_skipmissingRating_mean_skipmissingBudget_median_skipmissingRating_median_skipmissingFloat64Float64Float64Float64113.41255.932853.06.1 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/arrange/","title":"@arrange","text":"<p>Arranging is the way to sort a data frame. <code>@arrange()</code> can take multiple arguments. Arguments refer to columns that are sorted in ascending order by default. If you want to sort in descending order, make sure to wrap the column name in <code>desc()</code> as shown below.</p> <p><code>DataFrames.jl</code> does not currently support the <code>sort()</code> function on grouped data frames. In order to make this work in <code>Tidier.jl</code>, if you apply <code>@arrange()</code> to a GroupedDataFrame, <code>@arrange()</code> will temporarily ungroup the data, perform the <code>sort()</code>, and then re-group by the original grouping variables.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/arrange/#sort-both-variables-in-ascending-order","title":"Sort both variables in ascending order","text":"<pre><code>@chain movies begin\n@arrange(Year, Rating)\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641Blacksmith Scene18931missing7.02Hadj Cheriff18941missing4.13Glenroy Bros., No. 218941missing4.24Leonard-Cushing Fight18941missing4.45Sioux Ghost Dance18941missing4.4"},{"location":"examples/generated/UserGuide/arrange/#sort-in-a-mix-of-ascending-and-descending-order","title":"Sort in a mix of ascending and descending order","text":"<p>To sort in descending order, make sure to wrap the variable inside of <code>desc()</code>.</p> <pre><code>@chain movies begin\n@arrange(Year, desc(Rating))\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641Blacksmith Scene18931missing7.02Luis Martinetti, Contortionist18941missing6.13Caicedo (with Pole)18941missing5.84Glenroy Brothers (Comic Boxing)18941missing5.45Buffalo Dance18941missing5.0 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/autovec/","title":"Auto-vectorization","text":"<p>In general, Tidier.jl uses a lookup table to decide which functions not to vectorize. For example, <code>mean()</code> is listed as a function that should never be vectorized. Also, any function used inside of <code>@summarize()</code> is also never automatically vectorized. Any function that is not included in this list and is used in a context other than <code>@summarize()</code> is automatically vectorized.</p> <p>This \"auto-vectorization\" makes working with Tidier.jl more R-like and convenient. However, if you ever define your own function and try to use it, Tidier.jl may unintentionally vectorize it for you. To prevent auto-vectorization, you can prefix your function with a <code>~</code>.</p> <pre><code>using Tidier\nusing RDatasets\n\ndf = DataFrame(a = repeat('a':'e', inner = 2), b = [1,1,1,2,2,2,3,3,3,4], c = 11:20)\n</code></pre> 10\u00d73 DataFrame RowabcCharInt64Int641a1112a1123b1134b2145c2156c2167d3178d3189e31910e420 <p>For example, let's define a function <code>new_mean()</code> that calculates a mean.</p> <pre><code>new_mean(exprs...) = mean(exprs...)\n</code></pre> <pre><code>new_mean (generic function with 1 method)\n</code></pre> <p>If we try to use <code>new_mean()</code> inside of <code>@mutate()</code>, it will give us the wrong result. This is because <code>new_mean()</code> is vectorized, which results in the mean being calculated element-wise, which is almost never what we actually want.</p> <pre><code>@chain df begin\n@mutate(d = c - new_mean(c))\nend\n</code></pre> 10\u00d74 DataFrame RowabcdCharInt64Int64Float641a1110.02a1120.03b1130.04b2140.05c2150.06c2160.07d3170.08d3180.09e3190.010e4200.0 <p>To prevent <code>new_mean()</code> from being vectorized, we need to prefix it with a <code>~</code> like this:</p> <pre><code>@chain df begin\n@mutate(d = c - ~new_mean(c))\nend\n</code></pre> 10\u00d74 DataFrame RowabcdCharInt64Int64Float641a111-4.52a112-3.53b113-2.54b214-1.55c215-0.56c2160.57d3171.58d3182.59e3193.510e4204.5 <p>This gives us the correct answer. Notice that adding a <code>~</code> is not needed with <code>mean()</code> because <code>mean()</code> is already included on our look-up table of functions not requiring vectorization.</p> <pre><code>@chain df begin\n@mutate(d = c - mean(c))\nend\n</code></pre> 10\u00d74 DataFrame RowabcdCharInt64Int64Float641a111-4.52a112-3.53b113-2.54b214-1.55c215-0.56c2160.57d3171.58d3182.59e3193.510e4204.5 <p>If you're not sure if a function is vectorized and want to prevent it from being vectorized, you can always prefix it with a ~ to prevent vectorization. Even though <code>mean()</code> is not vectorized anyway, prefixing it with a ~ will not cause any harm.</p> <pre><code>@chain df begin\n@mutate(d = c - ~mean(c))\nend\n</code></pre> 10\u00d74 DataFrame RowabcdCharInt64Int64Float641a111-4.52a112-3.53b113-2.54b214-1.55c215-0.56c2160.57d3171.58d3182.59e3193.510e4204.5 <p>If for some crazy reason, you did want to vectorize <code>mean()</code>, you are always allowed to vectorize it, and Tidier.jl won't un-vectorize it.</p> <pre><code>@chain df begin\n@mutate(d = c - mean.(c))\nend\n</code></pre> 10\u00d74 DataFrame RowabcdCharInt64Int64Float641a1110.02a1120.03b1130.04b2140.05c2150.06c2160.07d3170.08d3180.09e3190.010e4200.0 <p>Note: <code>~</code> also works with operators, so if you want to not vectorize an operator, you can prefix it with <code>~</code>, for example, <code>a ~* b</code> will perform a matrix multiplication rather than element-wise multiplication. Remember that this is only needed outside of <code>@summarize()</code> because <code>@summarize()</code> never performs auto-vectorization.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/binding/","title":"Binding","text":"<p>Whereas joins are useful for combining data frames based on matching keys, another way to combine data frames is to bind them together, which can be done either by rows or by columns. <code>Tidier.jl</code> implements these actions using <code>@bind_rows()</code> and <code>@bind_cols()</code>, respectively.</p> <p>Let's generate three data frames to combine.</p> <pre><code>using Tidier\n\ndf1 = DataFrame(a=1:3, b=1:3);\n\ndf2 = DataFrame(a=4:6, b=4:6);\n\ndf3 = DataFrame(a=7:9, c=7:9);\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/binding/#bind_rows","title":"<code>@bind_rows()</code>","text":"<pre><code>@bind_rows(df1, df2)\n</code></pre> 6\u00d72 DataFrame RowabInt64Int64111222333444555666 <p><code>@bind_rows()</code> keeps columns that are present in at least one of the provided data frames. Any missing columns will be filled with <code>missing</code> values.</p> <pre><code>@bind_rows(df1, df3)\n</code></pre> 6\u00d73 DataFrame RowabcInt64Int64?Int64?111missing222missing333missing47missing758missing869missing9 <p>There is an optional <code>id</code> argument to add an identifier for combined data frames. Note that both <code>@bind_rows</code> and <code>@bind_cols</code> accept multiple (i.e., more than 2) data frames, as in the example below.</p> <pre><code>@bind_rows(df1, df2, df3, id = \"id\")\n</code></pre> 9\u00d74 DataFrame RowabcidInt64Int64?Int64?Int64111missing1222missing1333missing1444missing2555missing2666missing277missing7388missing8399missing93 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/binding/#bind_cols","title":"<code>@bind_cols()</code>","text":"<p><code>@bind_cols</code> works similarly to R's <code>tidyverse</code> although the <code>.name_repair</code> argument is not supported.</p> <pre><code>@bind_cols(df1, df2)\n</code></pre> 3\u00d74 DataFrame Rowaba_1b_1Int64Int64Int64Int64111442225533366 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/column_names/","title":"Column names","text":"<p>When referring to column names, Tidier.jl is a bit unusual for a Julia package in that it does not use symbols. This is because Tidier.jl uses tidy expressions, which in R lingo equates to a style of programming referred to as \"non-standard evaluation.\" If you are creating a new column <code>a</code> containing a value that is the mean of column <code>b</code>, you would simply write <code>a = mean(b)</code>.</p> <p>However, there may be times when you wish to create or refer to a column containing a space in it. Let's start by creating some column names containing a space in their name.</p> <pre><code>using Tidier\n\ndf = DataFrame(var\"my name\" = [\"Ada\", \"Twist\"],\nvar\"my age\" = [40, 50])\n</code></pre> 2\u00d72 DataFrame Rowmy namemy ageStringInt641Ada402Twist50 <p>To create a column name containing a space, we used the <code>var\"column name\"</code> notation. Because <code>DataFrame()</code> is a regular Julia function, this is the standard way to refer to a variable containing a space, which is why we need to use this here.</p> <p>This notation also works inside of Tidier.jl.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/column_names/#varcolumn-name-notation","title":"<code>var\"column name\"</code> notation","text":"<p>If we want to figure out the age for the people in our dataset a decade from today, we could use this same <code>var\"column name\"</code> notation inside of <code>@mutate</code>.</p> <pre><code>@chain df begin\n@mutate(var\"age in 10 years\" = var\"my age\" + 10)\nend\n</code></pre> 2\u00d73 DataFrame Rowmy namemy ageage in 10 yearsStringInt64Int641Ada40502Twist5060 <p>However, typing out the <code>var\"column name\"</code> can become cumbersome. Tidier.jl also supports another shorthand notation to refer to column names containing spaces or other special characters: backticks.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/column_names/#backtick-notation","title":"Backtick notation","text":"<p>This same code could be written more concisely like this:</p> <pre><code>@chain df begin\n@mutate(`age in 10 years` = `my age` + 10)\nend\n</code></pre> 2\u00d73 DataFrame Rowmy namemy ageage in 10 yearsStringInt64Int641Ada40502Twist5060 <p>Backticks are an R convention. While they are not specific to tidyverse, they are a convenient way to refer to column names that otherwise would not parse correctly as a single entity. Backticks are supported in all Tidier.jl functions where column names may be referenced.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/column_names/#cleaning-up-column-names","title":"Cleaning up column names","text":"<p>Another option is to clean up the column names so that you do not have spaces to begin with. In R, this is usually accomplished using the <code>janitor</code> package. In Julia, the Cleaner.jl package provides this functionality, which we have wrapped inside of Tidier.jl.</p> <pre><code>@chain df begin\n@clean_names\nend\n</code></pre> 2\u00d72 DataFrame Rowmy_namemy_ageStringInt641Ada402Twist50 <p>Although the default value for the <code>case</code> argument is \"snake_case\", you can also set this to \"camelCase\".</p> <pre><code>@chain df begin\n@clean_names(case = \"camelCase\")\nend\n</code></pre> 2\u00d72 DataFrame RowmyNamemyAgeStringInt641Ada402Twist50 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/conditionals/","title":"Conditionals","text":"<p>Conditional functions are a useful tool to update or create new columns conditional on the values of a column of data. When continuous variables are converted to categories, this is sometimes referred to as \"recoding\" a column.</p> <p>Tidier.jl provides two functions to recode data: <code>if_else()</code> and <code>case_when()</code>.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/conditionals/#if_else","title":"<code>if_else()</code>","text":"<p>Why do we need another <code>if_else()</code> function if base Julia already comes with an <code>ifelse()</code> function. Similar to R, the base Julia implementation of <code>if_else()</code> does not include a way to designate what value to return if the enclosed vector contains a missing value. Additionally, the base Julia implementation of <code>ifelse()</code> produces an error if presented with a <code>missing</code> value in the condition. The Tidier.jl <code>if_else()</code> can handle missing values and includes an optional 4th argument that is used to designate what to return in the event of a `missing`` value for the condition. Let's take a look at some examples.</p> <pre><code>using Tidier\n\ndf = DataFrame(a = [1, 2, missing, 4, 5])\n</code></pre> 5\u00d71 DataFrame RowaInt64?11223missing4455 <p>Here, we have created a <code>DataFrame</code> containing a single column <code>a</code> with 5 values, for which the 3rd value is missing.</p> <p>Now, let's create a new column <code>b</code> that contains a \"yes\" if <code>a</code> is greater than or equal to 3, and a \"no\" otherwise. Notice that when we do this, the <code>missing</code> values remains as <code>missing</code>.</p> <pre><code>@chain df begin\n@mutate(b = if_else(a &gt;= 3, \"yes\", \"no\"))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?String?11no22no3missingmissing44yes55yes <p>What if we wanted to fill in the missing value with \"unknown\"? All we need to do is provide an optional 4th argument containing the value to return in the event of a missing condition. When we run this version, <code>missing</code> values in <code>a</code> are converted to \"unknown\" in <code>b</code>.</p> <pre><code>@chain df begin\n@mutate(b = if_else(a &gt;= 3, \"yes\", \"no\", \"unknown\"))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?String11no22no3missingunknown44yes55yes <p>Although both of these examples showed how to return a single value (like \"yes\" and \"no\"), you can also return a vector of values, which is useful for updating only a subset of the values of a column. For example, if we wanted to create a column <code>b</code> that contains a 3 when <code>a</code> is greater than or equal to 3 but otherwise remains unchanged, we could provide a 3 for the <code>yes</code> condition and a vector (column) <code>a</code> in the <code>no</code> condition. If we do not provide the optional 4th argument, <code>missing</code> values remain <code>missing</code>.</p> <pre><code>@chain df begin\n@mutate(b = if_else(a &gt;= 3, 3, a))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?Int64?1112223missingmissing443553 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/conditionals/#case_when","title":"<code>case_when()</code>","text":"<p>Although <code>if_else()</code> is convenient when evaluating a single condition, it can be cumbersome when evaluating multiple conditions because subsequent conditions need to be nested within the <code>no</code> condition for the preceding argument. For situations where multiple conditions need to be evaluated, <code>case_when()</code> is more convenient.</p> <p>Let's first consider a similar example from above and recreate it using <code>case_when()</code>. The following code creates a column <code>b</code> that assigns a value if 3 if <code>a &gt;= 3</code> and otherwise leaves the value unchanged.</p> <pre><code>@chain df begin\n@mutate(b = case_when(a &gt;= 3  =&gt;  3,\ntrue    =&gt;  a))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?Int64?1112223missingmissing443553 <p>What is going on here? <code>case_when()</code> uses a <code>condition =&gt; return_value</code> syntax, which are encoded as pairs in Julia. You can provide a single pair, or multiple pairs separated by commas. Because the pairs operator (<code>=&gt;</code>) might be confused with a greater than or equal to sign (<code>&gt;=</code>), we have padded two spaces on either side of the <code>=&gt;</code> to make sure that the pair remains visually distinct. We do not use a <code>~</code> operator in <code>case_when()</code> (as is used in R) because the <code>~</code> operator is used to denote de-vectorized functions in Tidier.jl.</p> <p>There are 2 other things to note above. First, the <code>true</code> condition evaluates to <code>true</code> for all remaining values of <code>a</code>. The only reason that the <code>b</code> contains a <code>missing</code> value here is that the <code>true</code> condition was met, leading to the value of <code>a</code> (in this case, <code>missing</code>) to be assigned to <code>b</code>. Second, we were able to return a single value (3) in the first condition, and a vector (column) of data (<code>a</code>) in the second condition.</p> <p>What if we wanted to fill in the missing values with something else? In this case, we would need to create an explicit condition that checks for missing values and assigns a return value to that condition.</p> <pre><code>@chain df begin\n@mutate(b = case_when(a &gt;= 3        =&gt;  3,\nismissing(a)  =&gt;  0,\ntrue          =&gt;  a))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?Int641112223missing0443553 <p>Do our conditions have to be mutually exclusive? No. The return value for the first matching condition is assigned to <code>b</code> because the conditions are evaluated sequentially from first to last.</p> <pre><code>@chain df begin\n@mutate(b = case_when(a &gt; 4  =&gt;  \"hi\",\na &gt; 2  =&gt;  \"medium\",\na &gt; 0  =&gt;  \"low\"))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?String?11low22low3missingmissing44medium55hi <p>Again, if we want to fill in remaining values (which in this case are the <code>missing</code> ones), we can map the final condition <code>true</code> to the value of \"unknown\". Because the ordering of the conditions matters, the <code>true</code> condition should always be listed last if it is included.</p> <pre><code>@chain df begin\n@mutate(b = case_when(a &gt; 4  =&gt;  \"hi\",\na &gt; 2  =&gt;  \"medium\",\na &gt; 0  =&gt;  \"low\",\ntrue   =&gt;  \"unknown\"))\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64?String11low22low3missingunknown44medium55hi <p></p> <p></p>"},{"location":"examples/generated/UserGuide/conditionals/#do-these-functions-work-outside-of-tidierjl","title":"Do these functions work outside of Tidier.jl?","text":"<p>Yes, both <code>if_else()</code> and <code>case_when()</code> work outside of Tidier.jl. However, you'll need to remember that if working with vectors, both the functions and conditions will need to be vectorized, and in the case of <code>case_when()</code>, the <code>=&gt;</code> will need to be written as <code>.=&gt;</code>. The reason this is not needed when using these functions inside of Tidier.jl is because they are auto-vectorized.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/dataset_movies/","title":"Movies dataset","text":"<p>To get started, we will load the <code>movies</code> dataset from the <code>RDatasets.jl</code> package.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p>To work with this dataset, we will use the <code>@chain</code> macro. This macro initiates a pipe, and every function or macro provided to it between the <code>begin</code> and <code>end</code> blocks modifies the dataframe mentioned at the beginning of the pipe. You don't have to necessarily spread a chain over multiple lines of code, but when working with data frames it's often easiest to do so. Before going further, take a look at the Chain.jl GitHub page to see all the cool things that are possible with this, including mid-chain side effects using <code>@aside</code> and mid-chain assignment of variables.</p> <p>Let's take a look at the first 5 rows of the <code>movies</code> dataset using <code>@slice()</code>.</p> <pre><code>@chain movies begin\n@slice(1:5)\nend\n</code></pre> 5\u00d724 DataFrame RowTitleYearLengthBudgetRatingVotesR1R2R3R4R5R6R7R8R9R10MPAAActionAnimationComedyDramaDocumentaryRomanceShortStringInt32Int32Int32?Float64Int32Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Cat\u2026Int32Int32Int32Int32Int32Int32Int321$1971121missing6.43484.54.54.54.514.524.524.514.54.54.500110002$1000 a Touchdown193971missing6.0200.014.54.524.514.514.514.54.54.514.500100003$21 a Day Once a Month19417missing8.250.00.00.00.00.024.50.044.524.524.501000014$40,000199670missing8.2614.50.00.00.00.00.00.00.034.545.500100005$50,000 Climax Show, The197571missing3.41724.54.50.014.514.54.50.00.00.024.50000000 <p>Let's use <code>@glimpse()</code> to preview the dataset.</p> <pre><code>@glimpse(movies)\n</code></pre> <pre><code>Rows: 58788\nColumns: 24\n.Title         String         $, $1000 a Touchdown, $21 a Day Once a Month, $40,\n.Year          Int32          1971, 1939, 1941, 1996, 1975, 2000, 2002, 2002, 19\n.Length        Int32          121, 71, 7, 70, 71, 91, 93, 25, 97, 61, 99, 96, 10\n.Budget        Union{Missing, Int32}missing, missing, missing, missing, missing,\n.Rating        Float64        6.4, 6.0, 8.2, 8.2, 3.4, 4.3, 5.3, 6.7, 6.6, 6.0,\n.Votes         Int32          348, 20, 5, 6, 17, 45, 200, 24, 18, 51, 23, 53, 44\n.R1            Float64        4.5, 0.0, 0.0, 14.5, 24.5, 4.5, 4.5, 4.5, 4.5, 4.5\n.R2            Float64        4.5, 14.5, 0.0, 0.0, 4.5, 4.5, 0.0, 4.5, 4.5, 0.0,\n.R3            Float64        4.5, 4.5, 0.0, 0.0, 0.0, 4.5, 4.5, 4.5, 4.5, 4.5,\n.R4            Float64        4.5, 24.5, 0.0, 0.0, 14.5, 14.5, 4.5, 4.5, 0.0, 4.\n.R5            Float64        14.5, 14.5, 0.0, 0.0, 14.5, 14.5, 24.5, 4.5, 0.0,\n.R6            Float64        24.5, 14.5, 24.5, 0.0, 4.5, 14.5, 24.5, 14.5, 0.0,\n.R7            Float64        24.5, 14.5, 0.0, 0.0, 0.0, 4.5, 14.5, 14.5, 34.5,\n.R8            Float64        14.5, 4.5, 44.5, 0.0, 0.0, 4.5, 4.5, 14.5, 14.5, 4\n.R9            Float64        4.5, 4.5, 24.5, 34.5, 0.0, 14.5, 4.5, 4.5, 4.5, 4.\n.R10           Float64        4.5, 14.5, 24.5, 45.5, 24.5, 14.5, 14.5, 14.5, 24.\n.MPAA          CategoricalArrays.CategoricalValue{String, UInt8}, , , , , , R, ,\n.Action        Int32          0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,\n.Animation     Int32          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n.Comedy        Int32          1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0,\n.Drama         Int32          1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1,\n.Documentary   Int32          0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n.Romance       Int32          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n.Short         Int32          0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/distinct/","title":"@distinct","text":"<p>The <code>@distinct()</code> macro in <code>Tidier.jl</code> is useful to select distinct rows. Like it's R counterpart, it can be used with or without arguments. When arguments are provided, it behaves slightly differently than the R version. Whereas the R function only returns the provided columns, the Tidier.jl version returns all columns, where the first match is returned for the non-selected columns.</p> <pre><code>using Tidier\n\ndf = DataFrame(a = 1:10, b = repeat('a':'e', inner = 2))\n</code></pre> 10\u00d72 DataFrame RowabInt64Char11a22a33b44b55c66c77d88d99e1010e <p></p> <p></p>"},{"location":"examples/generated/UserGuide/distinct/#select-distinct-values-overall","title":"Select distinct values overall","text":"<p>Since there are no duplicate rows, this will return all rows.</p> <pre><code>@chain df begin\n@distinct()\nend\n</code></pre> 10\u00d72 DataFrame RowabInt64Char11a22a33b44b55c66c77d88d99e1010e <p></p> <p></p>"},{"location":"examples/generated/UserGuide/distinct/#select-distinct-values-based-on-column-b","title":"Select distinct values based on column <code>b</code>","text":"<p>Notice that the first matching row for column <code>a</code> is returned for every distinct value of column <code>b</code>. This is slightly different behavior than R's tidyverse, which would have returned only column <code>b</code>.</p> <pre><code>@chain df begin\n@distinct(b)\nend\n</code></pre> 5\u00d72 DataFrame RowabInt64Char11a23b35c47d59e <p>In Tidier.jl, <code>@distinct()</code> works with grouped data frames. If grouped, <code>@distinct()</code> will ignore the grouping when determining distinct values but will return the data frame in grouped form based on the original groupings.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/filter/","title":"@filter","text":"<p>Filtering is a mechanism to indicate which rows you want to keep in a dataset based on criteria. This is also referred to as subsetting. Filtering rows is normally a bit tricky in <code>DataFrames.jl</code> because comparison operators like <code>&gt;=</code> actually need to be vectorized as <code>.&gt;=</code>, which can catch new Julia users by surprise. <code>@filter()</code> mimics R's <code>tidyverse</code> behavior by auto-vectorizing the code and then only selecting those rows that evaluate to <code>true</code>. Similar to <code>dplyr</code>, rows that evaluate to <code>missing</code> are skipped.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p>Let\u2019s take a look at the movies whose budget was more than average. We will select only the first 5 rows for the sake of brevity.</p> <pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@filter(Budget &gt;= mean(skipmissing(Budget)))\n@select(Title, Budget)\n@slice(1:5)\nend\n</code></pre> 5\u00d72 DataFrame RowTitleBudgetStringFloat64?1'Til There Was You23.0210 Things I Hate About You16.03102 Dalmatians85.0413 Going On 3037.0513th Warrior, The85.0 <p>Let's search for movies that have at least 200 votes and a rating of greater than or equal to 8. There are 3 ways you can specify an \"and\" condition inside of <code>Tidier.jl</code>.</p> <pre><code># The first option is to use the short-circuiting `&amp;&amp;` operator as shown below. This is the preferred approach because the second expression is only evaluated (per element) if the first one is true.\n\n@chain movies begin\n@filter(Votes &gt;= 200 &amp;&amp; Rating &gt;= 8)\n@select(Title, Votes, Rating)\n@slice(1:5)\nend\n\n# The second option is to use the bitwise `&amp;` operator. However, there is a key difference in syntax. Because the `&amp;` operator takes a higher operator precendence than `&gt;=`, you have to wrap the `&gt;=` expressions inside of parentheses to ensure that the expression is evaluated correctly.\n\n@chain movies begin\n@filter((Votes &gt;= 200) &amp; (Rating &gt;= 8))\n@select(Title, Votes, Rating)\n@slice(1:5)\nend\n\n# Finally, for \"and\" conditions only, you can separate the expressions with commas, similar to the behavior of `filter()` in `tidyverse`.\n\n@chain movies begin\n@filter(Votes &gt;= 200, Rating &gt;= 8)\n@select(Title, Votes, Rating)\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowTitleVotesRatingStringInt32Float64112 Angry Men292788.7212 stulev2528.932001: A Space Odyssey649828.3421 Grams218578.0539 Steps, The79318.0 <p>Now let's see how to use <code>@filter()</code> with <code>in</code>. Here's an example with a tuple.</p> <pre><code>@chain movies begin\n@filter(Title in (\"101 Dalmatians\",\n\"102 Dalmatians\"))\n@select(1:5)\nend\n</code></pre> 2\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641101 Dalmatians1996103missing5.52102 Dalmatians2000100850000004.7 <p>We can also use <code>@filter()</code> with <code>in</code> using a vector, denoted by a <code>[]</code>.</p> <pre><code>@chain movies begin\n@filter(Title in [\"101 Dalmatians\",\n\"102 Dalmatians\"])\n@select(1:5)\nend\n</code></pre> 2\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641101 Dalmatians1996103missing5.52102 Dalmatians2000100850000004.7 <p>Finally, we can combine <code>@filter</code> with <code>row_number()</code> to retrieve the first 5 rows, which can be used to mimic the functionality provided by <code>@slice</code>.</p> <pre><code>@chain movies begin\n@filter(row_number() &lt;= 5)\n@select(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/group_by/","title":"@group_by","text":"<p>Grouping and ungrouping behavior is one of the nicest parts of using R's tidyverse. Once a data frame is grouped, all verbs applied to that data frame respect the grouping, including but not limited to <code>@mutate()</code>, <code>@summarize()</code>, <code>@slice()</code> and <code>@filter</code>, which allows for really powerful abstractions. For example, with <code>@group_by()</code> followed by <code>@filter()</code>, you can limit the rows of a dataset to the maximum or minimum values for each group.</p> <p>Exactly as in R's <code>tidyverse</code>, once a data frame is grouped, it remains grouped until either <code>@summarize()</code> is called (which \"peels off\" one layer of grouping) or <code>@ungroup()</code> is called, which removes all layers of grouping. Also as in R's <code>tidyverse</code>, <code>@group_by()</code> sorts the groups in ascending order. Unlike in R, there is never any question about whether a data frame is currently grouped because GroupedDataFrames print out in a very different form than DataFrames, making them easy to tell apart.</p> <p>When using <code>@chain</code>, note that you can write either <code>@ungroup</code> or <code>@ungroup()</code>. Both are considered valid.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/group_by/#combining-group_by-with-mutate","title":"Combining <code>@group_by()</code> with <code>@mutate()</code>","text":"<pre><code>@chain movies begin\n@group_by(Year)\n@mutate(Mean_Yearly_Rating = mean(skipmissing(Rating)))\n@select(Year, Rating, Mean_Yearly_Rating)\n@ungroup\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowYearRatingMean_Yearly_RatingInt32Float64Float64118937.07.0218944.64.88889318945.04.88889418945.84.88889518944.24.88889"},{"location":"examples/generated/UserGuide/group_by/#combining-group_by-with-summarize","title":"Combining @group_by() with @summarize()","text":"<pre><code>@chain movies begin\n@group_by(Year)\n@summarize(Mean_Yearly_Rating = mean(skipmissing(Rating)),\nMedian_Yearly_Rating = median(skipmissing(Rating)))\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowYearMean_Yearly_RatingMedian_Yearly_RatingInt32Float64Float64118937.07.0218944.888894.6318955.55.7418965.269235.3518974.677784.6"},{"location":"examples/generated/UserGuide/group_by/#grouping-by-multiple-columns","title":"Grouping by multiple columns","text":"<pre><code>@chain movies begin\n@group_by(Year, Comedy)\n@summarize(Mean_Yearly_Rating = mean(skipmissing(Rating)),\nMedian_Yearly_Rating = median(skipmissing(Rating)))\n@ungroup # Need to ungroup to peel off grouping by Year\n@arrange(desc(Year), Comedy)\n@slice(1:5)\nend\n</code></pre> 5\u00d74 DataFrame RowYearComedyMean_Yearly_RatingMedian_Yearly_RatingInt32Int32Float64Float641200506.627886.752200516.300816.13200406.765216.94200416.428986.65200306.404096.6"},{"location":"examples/generated/UserGuide/group_by/#combining-group_by-with-filter","title":"Combining @group_by() with @filter()","text":"<pre><code>@chain movies begin\n@group_by(Year)\n@filter(Rating == minimum(Rating))\n@ungroup\n@select(Year, Rating)\n@arrange(desc(Year))\n@slice(1:10)\nend\n</code></pre> 10\u00d72 DataFrame RowYearRatingInt32Float64120051.8220041.0320041.0420041.0520041.0620041.0720041.0820041.0920031.01020031.0 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/interpolation/","title":"Interpolation","text":"<p>The <code>!!</code> (\"bang bang\") operator can be used to interpolate values of variables from the global environment into your code. This operator is borrowed from the R <code>rlang</code> package. At some point, we may switch to using native Julia interpolation, but for a variety of reasons that introduce some complexity with native interpolation, we plan to continue to support <code>!!</code> interpolation.</p> <p>To interpolate multiple variables, the <code>rlang</code> R package uses the <code>!!!</code> \"triple bang\" operator. However, in <code>Tidier.jl</code>, the <code>!!</code> \"bang bang\" operator can be used to interpolate either single or multiple values as shown in the examples below.</p> <p>Since the <code>!!</code> operator can only access variables in the global environment, we will set these variables in a somewhat roundabout way for the purposes of documentation. However, in interactive use, you can simply write <code>myvar = :b</code> instead of wrapping this code inside of an <code>@eval()</code> macro as is done here.</p> <p>Note: <code>myvar = :b</code>, <code>myvar = (:a, :b)</code>, and <code>myvar = [:a, :b]</code> all refer to columns with those names. On the other hand, <code>myvar = \"b\"</code>, <code>myvar = (\"a\", \"b\")</code> and <code>myvar = [\"a\", \"b\"]</code> will interpolate those values. See below for examples.</p> <pre><code>using Tidier\n\ndf = DataFrame(a = string.(repeat('a':'e', inner = 2)),\nb = [1,1,1,2,2,2,3,3,3,4],\nc = 11:20)\n</code></pre> 10\u00d73 DataFrame RowabcStringInt64Int641a1112a1123b1134b2145c2156c2167d3178d3189e31910e420 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/interpolation/#select-the-column-because-myvar-contains-a-symbol","title":"Select the column (because <code>myvar</code> contains a symbol)","text":"<pre><code>@eval(Main, myvar = :b)\n\n@chain df begin\n@select(!!myvar)\nend\n</code></pre> 10\u00d71 DataFrame RowbInt64112131425262738393104"},{"location":"examples/generated/UserGuide/interpolation/#select-multiple-variables-tuple-of-symbols","title":"Select multiple variables (tuple of symbols)","text":"<pre><code>@eval(Main, myvars_tuple = (:a, :b))\n\n@chain df begin\n@select(!!myvars_tuple)\nend\n</code></pre> 10\u00d72 DataFrame RowabStringInt641a12a13b14b25c26c27d38d39e310e4"},{"location":"examples/generated/UserGuide/interpolation/#select-multiple-variables-vector-of-symbols","title":"Select multiple variables (vector of symbols)","text":"<pre><code>@eval(Main, myvars_vector = [:a, :b])\n\n@chain df begin\n@select(!!myvars_vector)\nend\n</code></pre> 10\u00d72 DataFrame RowabStringInt641a12a13b14b25c26c27d38d39e310e4"},{"location":"examples/generated/UserGuide/interpolation/#filter-rows-containing-the-value-of-myvar_string-because-myvar_string-does","title":"Filter rows containing the value of <code>myvar_string</code> (because <code>myvar_string</code> does)","text":"<pre><code>@eval(Main, myvar_string = \"b\")\n\n@chain df begin\n@filter(a == !!myvar_string)\nend\n</code></pre> 2\u00d73 DataFrame RowabcStringInt64Int641b1132b214"},{"location":"examples/generated/UserGuide/interpolation/#filtering-rows-works-similarly-using-in","title":"Filtering rows works similarly using <code>in</code>.","text":"<p>Note that for <code>in</code> to work here, we have to wrap it in <code>[]</code> because otherwise, the string will be converted into a collection of characters, which are a different data type.</p> <pre><code>@eval(Main, myvar_string = \"b\")\n\n@chain df begin\n@filter(a in [!!myvar_string])\nend\n</code></pre> 2\u00d73 DataFrame RowabcStringInt64Int641b1132b214 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/interpolation/#you-can-also-use-this-for-a-tuple-or-vector-of-strings","title":"You can also use this for a tuple or vector of strings.","text":"<pre><code>@eval(Main, myvars_string = (\"a\", \"b\"))\n\n@chain df begin\n@filter(a in !!myvars_string)\nend\n</code></pre> 4\u00d73 DataFrame RowabcStringInt64Int641a1112a1123b1134b214"},{"location":"examples/generated/UserGuide/interpolation/#mutate-one-variable","title":"Mutate one variable","text":"<pre><code>@eval(Main, myvar = :b)\n\n@chain df begin\n@mutate(!!myvar = !!myvar + 1)\nend\n</code></pre> 10\u00d73 DataFrame RowabcStringInt64Int641a2112a2123b2134b3145c3156c3167d4178d4189e41910e520"},{"location":"examples/generated/UserGuide/interpolation/#summarize-across-one-variable","title":"Summarize across one variable","text":"<pre><code>@eval(Main, myvar = :b)\n\n@chain df begin\n@summarize(across(!!myvar, mean))\nend\n</code></pre> 1\u00d71 DataFrame Rowb_meanFloat6412.2"},{"location":"examples/generated/UserGuide/interpolation/#summarize-across-multiple-variables","title":"Summarize across multiple variables","text":"<pre><code>@eval(Main, myvars_tuple = (:b, :c))\n\n@chain df begin\n@summarize(across(!!myvars_tuple, (mean, minimum, maximum)))\nend\n</code></pre> 1\u00d76 DataFrame Rowb_meanc_meanb_minimumc_minimumb_maximumc_maximumFloat64Float64Int64Int64Int64Int6412.215.5111420"},{"location":"examples/generated/UserGuide/interpolation/#group-by-multiple-interpolated-variables","title":"Group by multiple interpolated variables","text":"<pre><code>@eval(Main, myvars_tuple = (:a, :b))\n\n@chain df begin\n@group_by(!!myvars_tuple)\n@summarize(c = mean(c))\nend\n</code></pre> <p>GroupedDataFrame with 5 groups based on key: a</p> First Group (1 row): a = \"a\" RowabcStringInt64Float641a111.5 <p>&amp;vellip;</p> Last Group (2 rows): a = \"e\" RowabcStringInt64Float641e319.02e420.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/interpolation/#global-constants","title":"Global constants","text":"<p>Because global constants like <code>pi</code> exist in the <code>Main</code> module, they can also be accessed using interpolation. For example, let's calculate the area of circles with a radius of 1 up to 5.</p> <pre><code>df = DataFrame(radius = 1:5)\n</code></pre> 5\u00d71 DataFrame RowradiusInt641122334455 <p>We can interpolate <code>pi</code> (from the <code>Main</code> module) to help with this.</p> <pre><code>@chain df begin\n@mutate(area = !!pi * radius^2)\nend\n</code></pre> 5\u00d72 DataFrame RowradiusareaInt64Float64113.141592212.56643328.27434450.26555578.5398 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/interpolation/#alternative-interpolation-syntax","title":"Alternative interpolation syntax","text":"<p>While interpolation using <code>!!</code> is concise and handy, it's not required. You can also access user-defined globals and global constant variables using the following syntax:</p> <pre><code>@chain df begin\n@mutate(area = Main.pi * radius^2)\nend\n</code></pre> 5\u00d72 DataFrame RowradiusareaInt64Float64113.141592212.56643328.27434450.26555578.5398 <p>The key lesson with interpolation is that any bare unquoted variable is assumed to refer to a column name in the DataFrame. If you are referring to any variable outside of the DataFrame, you need to either use <code>!!variable</code> or <code>Main.variable</code> syntax to refer to this variable.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/joins/","title":"Joins","text":"<p>One really nice thing about the R <code>tidyverse</code> implementation of joins is that they support natural joins. If you don't specify which columns to join on, these column names are inferred from the overlapping columns. While you can override this behavior by specifying which columns to join on, it's convenient that this is not strictly required. We have adopted a similar approach to joins in <code>Tidier.jl</code>.</p> <p>Here, we will only show examples of natural joins. For additional ways to join, take a look at the examples in the Reference.</p> <pre><code>using Tidier\n</code></pre> <p>Let's generate two data frames to join on. Here's the first one.</p> <pre><code>df1 = DataFrame(a = [\"a\", \"b\"], b = 1:2);\n</code></pre> <p>And here's the second one.</p> <pre><code>df2 = DataFrame(a = [\"a\", \"c\"], c = 3:4);\n</code></pre> <p>All the joins work similarly to R's <code>tidyverse</code> although the new <code>join_by</code> syntax for non-equijoins is not (yet) supported.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/joins/#left-join","title":"Left join","text":"<pre><code>@left_join(df1, df2)\n</code></pre> 2\u00d73 DataFrame RowabcStringInt64Int64?1a132b2missing"},{"location":"examples/generated/UserGuide/joins/#right-join","title":"Right join","text":"<pre><code>@right_join(df1, df2)\n</code></pre> 2\u00d73 DataFrame RowabcStringInt64?Int641a132cmissing4"},{"location":"examples/generated/UserGuide/joins/#inner-join","title":"Inner join","text":"<pre><code>@inner_join(df1, df2)\n</code></pre> 1\u00d73 DataFrame RowabcStringInt64Int641a13"},{"location":"examples/generated/UserGuide/joins/#full-join","title":"Full join","text":"<pre><code>@full_join(df1, df2)\n</code></pre> 3\u00d73 DataFrame RowabcStringInt64?Int64?1a132b2missing3cmissing4 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/mutate_transmute/","title":"@mutate","text":"<p>The primary purpose of <code>@mutate()</code> is to either create a new column or to update an existing column without changing the number of rows in the dataset. If you only plan to select the mutated columns, then you can use <code>@transmute()</code> instead of <code>@mutate(). However, in</code>Tidier.jl<code>,</code>@select()<code>can also be used to create and select new columns (unlike R's</code>tidyverse<code>), which means that</code>@transmute()<code>is a redundant function in that it has the same functionality as</code>@select()<code>.</code>@transmute<code>is included in</code>Tidier.jl` for convenience but is not strictly required.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/mutate_transmute/#using-mutate-to-add-a-new-column","title":"Using <code>@mutate()</code> to add a new column","text":"<p>Let's create a new column that contains the budget for each movie expressed in millions of dollars, and the select a handful of columns and rows for the sake of brevity. Notice that the underscores in in <code>1_000_000</code> are strictly optional and included only for the sake of readability. Underscores within numbers are ignored by Julia, such that <code>1_000_000</code> is read by Julia exactly the same as <code>1000000</code>.</p> <pre><code>@chain movies begin\n@filter(!ismissing(Budget))\n@mutate(Budget_Millions = Budget/1_000_000)\n@select(Title, Budget, Budget_Millions)\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowTitleBudgetBudget_MillionsStringInt32?Float641'G' Men4500000.452'Manos' the Hands of Fate190000.0193'Til There Was You2300000023.04.com for Murder50000005.0510 Things I Hate About You1600000016.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/mutate_transmute/#using-mutate-to-update-an-existing-column","title":"Using <code>@mutate()</code> to update an existing column","text":"<p>Here we will repeat the same exercise, except that we will overwrite the existing <code>Budget</code> column.</p> <pre><code>@chain movies begin\n@filter(!ismissing(Budget))\n@mutate(Budget = Budget/1_000_000)\n@select(Title, Budget)\n@slice(1:5)\nend\n</code></pre> 5\u00d72 DataFrame RowTitleBudgetStringFloat641'G' Men0.452'Manos' the Hands of Fate0.0193'Til There Was You23.04.com for Murder5.0510 Things I Hate About You16.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/mutate_transmute/#using-mutate-with-in","title":"Using <code>@mutate()</code> with <code>in</code>","text":"<p>Here's an example of using <code>@mutate</code> with <code>in</code>.</p> <pre><code>@chain movies begin\n@filter(!ismissing(Budget))\n@mutate(Nineties = Year in 1990:1999)\n@select(Title, Year, Nineties)\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowTitleYearNinetiesStringInt32Bool1'G' Men1935false2'Manos' the Hands of Fate1966false3'Til There Was You1997true4.com for Murder2002false510 Things I Hate About You1999true <p></p> <p></p>"},{"location":"examples/generated/UserGuide/mutate_transmute/#using-mutate-with-n-and-row_number","title":"Using <code>@mutate</code> with <code>n()</code> and <code>row_number()</code>","text":"<p>Here's an example of using <code>@mutate</code> with both <code>n()</code> and <code>row_number()</code>. Within the context of <code>mutate()</code>, <code>n()</code> and <code>row_number()</code> are created into temporarily columns, which means that they can be used inside of expressions.</p> <pre><code>@chain movies begin\n@mutate(Row_Num = row_number(),\nTotal_Rows = n())\n@filter(!ismissing(Budget))\n@select(Title, Year, Row_Num, Total_Rows)\n@slice(1:5)\nend\n</code></pre> 5\u00d74 DataFrame RowTitleYearRow_NumTotal_RowsStringInt32Int64Int641'G' Men193522587882'Manos' the Hands of Fate196635587883'Til There Was You199748587884.com for Murder20029158788510 Things I Hate About You199911258788 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/mutate_transmute/#using-transmute-to-update-and-select-columns","title":"Using <code>@transmute</code> to update and select columns.","text":"<p>If we knew we wanted to select only the <code>Title</code> and <code>Budget</code> columns, we could have also used<code>@transmute()</code>, which (again) is just an alias for <code>@select()</code>.</p> <pre><code>@chain movies begin\n@filter(!ismissing(Budget))\n@transmute(Title = Title, Budget = Budget/1_000_000)\n@slice(1:5)\nend\n</code></pre> 5\u00d72 DataFrame RowTitleBudgetStringFloat641'G' Men0.452'Manos' the Hands of Fate0.0193'Til There Was You23.04.com for Murder5.0510 Things I Hate About You16.0 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/pivots/","title":"Pivoting","text":"<p>Pivoting a dataset is needed when information sitting inside of cell values needs to be converted into column names (to make the dataset wider) or vice verse (to make the dataset longer). Either action can be referred to as \"reshaping\" a dataset, and various frameworks refer to the actions as unstacking/stacking or spreading/gathering. In R's tidyverse, these actions are referred to as pivoting, where the two accompanying actions are <code>@pivot_wider()</code> and <code>@pivot_longer()</code>.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/pivots/#pivot_wider","title":"<code>@pivot_wider()</code>","text":"<p>Pivoting a dataset to make it wider is needed when information sitting inside of cell values needs to be converted into column names. The wider format is sometimes required for the purposes of calculating correlations or running statistical tests.</p> <p>Let's start with a \"long\" DataFrame and make it wide. Why would we want to make it wide? Well, if we wanted to calculate a correlation between <code>A</code> and <code>B</code> for rows with corresponding <code>id</code> numbers, we may need to first make sure that <code>A</code> and <code>B</code> are represented in adjacent columns.</p> <pre><code>using Tidier\n\ndf_long = DataFrame(id = [1, 1, 2, 2],\nvariable = [\"A\", \"B\", \"A\", \"B\"],\nvalue = [1, 2, 3, 4])\n</code></pre> 4\u00d73 DataFrame RowidvariablevalueInt64StringInt6411A121B232A342B4 <p>To make this dataset wider, we can do the following:</p> <pre><code>@pivot_wider(df_long, names_from = variable, values_from = value)\n</code></pre> 2\u00d73 DataFrame RowidABInt64Int64?Int64?11122234 <p>In <code>@pivot_wider()</code>, both the <code>names_from</code> and <code>values_from</code> arguments are required. <code>@pivot_wider()</code> also supports string values for the <code>names_from</code> and <code>values_from</code> arguments.</p> <pre><code>@pivot_wider(df_long, names_from = \"variable\", values_from = \"value\")\n</code></pre> 2\u00d73 DataFrame RowidABInt64Int64?Int64?11122234 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/pivots/#pivot_longer","title":"<code>@pivot_longer()</code>","text":"<p>For calculating summary statistics (e.g., mean) by groups, or for plotting purposes, DataFrames often need to be converted to their longer form. For this, we can use <code>@pivot_longer</code>. First, let's start with a \"wide\" DataFrame.</p> <pre><code>df_wide = DataFrame(id = [1, 2], A = [1, 3], B = [2, 4])\n</code></pre> 2\u00d73 DataFrame RowidABInt64Int64Int6411122234 <p>Now, let's transform this wide dataset into the longer form. Unlike <code>@pivot_wider()</code>, where providing the <code>names_from</code> and <code>values_from</code> arguments is required, the only item that's required in <code>@pivot_wider()</code> is a set of columns to pivot. The <code>names_to</code> and <code>values_to</code> arguments are optional, and if not provided, they will default to \"variable\" and \"value\", respectively.</p> <p>We can recreate the original long dataset by doing the following. Multiple columns must be provided using selection syntax or a selection helper. Tuples containing multiple columns are not yet supported.</p> <pre><code>@pivot_longer(df_wide, A:B)\n</code></pre> 4\u00d73 DataFrame RowidvariablevalueInt64StringInt6411A122A331B242B4 <p>Here is another way of providing the same result using a different type of selection syntax.</p> <pre><code>@pivot_longer(df_wide, -id)\n</code></pre> 4\u00d73 DataFrame RowidvariablevalueInt64StringInt6411A122A331B242B4 <p>In this example, we set the <code>names_to</code> and <code>values_to</code> arguments. Either argument can be left out and will revert to the default value. The <code>names_to</code> and <code>values_to</code> arguments can be provided as strings or as bare unquoted variable names.</p> <p>Here is an example with <code>names_to</code> and <code>values_to</code> containing strings:</p> <pre><code>@pivot_longer(df_wide, A:B, names_to = \"letter\", values_to = \"number\")\n</code></pre> 4\u00d73 DataFrame RowidletternumberInt64StringInt6411A122A331B242B4 <p>And here is an example with <code>names_to</code> and <code>values_to</code> containing bare unquoted variables:</p> <pre><code>@pivot_longer(df_wide, A:B, names_to = letter, values_to = number)\n</code></pre> 4\u00d73 DataFrame RowidletternumberInt64StringInt6411A122A331B242B4 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/rename/","title":"@rename","text":"<p>Renaming columns follows the same syntax as in R's <code>tidyverse</code>, where the \"tidy expression\" is <code>new_name = old_name</code>. While the main function to rename columns is <code>@rename()</code>, you can also use <code>@select()</code> if you additionally plan to select only the renamed columns.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/rename/#rename-using-rename","title":"Rename using <code>@rename()</code>","text":"<p>If you only want to rename the columns without selecting them, then this is where <code>@rename()</code> comes in handy. For the sake of brevity, we are selecting the first 5 columns and rows after performing the <code>@rename()</code>.</p> <pre><code>@chain movies begin\n@rename(title = Title, Minutes = Length)\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowtitleYearMinutesBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/rename/#rename-using-select","title":"Rename using <code>@select()</code>","text":"<p>If you plan to only select those columns that you would like to rename, then you can use <code>@select()</code> to both rename and select the columns of interest.</p> <pre><code>@chain movies begin\n@select(title = Title, Minutes = Length)\n@slice(1:5)\nend\n</code></pre> 5\u00d72 DataFrame RowtitleMinutesStringInt321$1212$1000 a Touchdown713$21 a Day Once a Month74$40,000705$50,000 Climax Show, The71 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/select/","title":"@select","text":"<p>The <code>@select()</code> macro in <code>Tidier.jl</code> supports many of the nuances of the R <code>tidyverse</code> implementation, including indexing columns individually by name or number, indexing by ranges of columns using the <code>:</code> operator between column names or numbers, and negative selection using negated column names or numbers. Selection helpers such as <code>starts_with()</code>, <code>ends_with()</code>, <code>matches()</code>, and <code>contains()</code> are also supported.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/select/#select-the-first-5-columns-individually-by-name","title":"Select the first 5 columns individually by name","text":"<pre><code>@chain movies begin\n@select(Title, Year, Length, Budget, Rating)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4"},{"location":"examples/generated/UserGuide/select/#select-the-first-5-columns-individually-by-number","title":"Select the first 5 columns individually by number","text":"<pre><code>@chain movies begin\n@select(1, 2, 3, 4, 5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4"},{"location":"examples/generated/UserGuide/select/#select-the-first-5-columns-by-name-using-a-range","title":"Select the first 5 columns by name (using a range)","text":"<pre><code>@chain movies begin\n@select(Title:Rating)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4"},{"location":"examples/generated/UserGuide/select/#select-the-first-5-columns-by-number-using-a-range","title":"Select the first 5 columns by number (using a range)","text":"<pre><code>@chain movies begin\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowTitleYearLengthBudgetRatingStringInt32Int32Int32?Float641$1971121missing6.42$1000 a Touchdown193971missing6.03$21 a Day Once a Month19417missing8.24$40,000199670missing8.25$50,000 Climax Show, The197571missing3.4"},{"location":"examples/generated/UserGuide/select/#select-all-but-the-first-5-columns-by-name","title":"Select all but the first 5 columns by name","text":"<p>Here we will limit the results to the first 5 remaining columns and the first 5 rows for the sake of brevity.</p> <pre><code>@chain movies begin\n@select(-(Title:Rating))\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowVotesR1R2R3R4Int32Float64Float64Float64Float6413484.54.54.54.52200.014.54.524.5350.00.00.00.04614.50.00.00.051724.54.50.014.5 <p>We can also use <code>!</code> for inverted selection instead of <code>-</code>.</p> <pre><code>@chain movies begin\n@select(!(Title:Rating))\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowVotesR1R2R3R4Int32Float64Float64Float64Float6413484.54.54.54.52200.014.54.524.5350.00.00.00.04614.50.00.00.051724.54.50.014.5 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/select/#select-all-but-the-first-5-columns-by-number","title":"Select all but the first 5 columns by number","text":"<p>We will again limit the results to the first 5 remaining columns and the first 5 rows for the sake of brevity.</p> <pre><code>@chain movies begin\n@select(-(1:5))\n@select(1:5)\n@slice(1:5)\nend\n</code></pre> 5\u00d75 DataFrame RowVotesR1R2R3R4Int32Float64Float64Float64Float6413484.54.54.54.52200.014.54.524.5350.00.00.00.04614.50.00.00.051724.54.50.014.5 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/select/#mix-and-match-selection","title":"Mix and match selection","text":"<p>Just like in R's <code>tidyverse</code>, you can separate multiple selections with commas and mix and match different ways of selecting columns.</p> <pre><code>@chain movies begin\n@select(1, Budget:Rating)\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame RowTitleBudgetRatingStringInt32?Float641$missing6.42$1000 a Touchdownmissing6.03$21 a Day Once a Monthmissing8.24$40,000missing8.25$50,000 Climax Show, Themissing3.4 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/slice/","title":"@slice","text":"<p>Slicing rows is similar to filtering rows, except that slicing is performed based on row numbers rather tha filter criteria. In <code>Tidier.jl</code>, slicing works similarly to R's <code>tidyverse</code> in that both positive (which rows to keep) and negative (which rows to remove) slicing is supported. For <code>@slice()</code>, any valid <code>UnitRange</code> of integers is considered valid; this is not the case for <code>@select()</code> or <code>across()</code>.</p> <p>Remember: Just like every other <code>Tidier.jl</code> top-level macro, <code>@slice()</code> respects group. This means that in a grouped data frame, <code>@slice(1:2)</code> will select the first 2 rows from each group.</p> <pre><code>using Tidier\n\ndf = DataFrame(row_num = 1:10,\na = string.(repeat('a':'e', inner = 2)),\nb = [1,1,1,2,2,2,3,3,3,4])\n</code></pre> 10\u00d73 DataFrame Rowrow_numabInt64StringInt6411a122a133b144b255c266c277d388d399e31010e4 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/slice/#slicing-using-a-range-of-numbers","title":"Slicing using a range of numbers","text":"<p>This is an easy way of retrieving 5 consecutive rows.</p> <pre><code>@chain df begin\n@slice(1:5)\nend\n</code></pre> 5\u00d73 DataFrame Rowrow_numabInt64StringInt6411a122a133b144b255c2 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/slice/#slicing-using-a-more-complex-unitrange-of-numbers","title":"Slicing using a more complex UnitRange of numbers","text":"<p>How would we obtain every other from 1 to 7 (counting up by 2)? Note that <code>range()</code> is similar to <code>seq()</code> in R.</p> <pre><code>@chain df begin\n@slice(range(start = 1, step = 2, stop = 7))\nend\n</code></pre> 4\u00d73 DataFrame Rowrow_numabInt64StringInt6411a123b135c247d3 <p>This same code can also be written using Julia's shorthand syntax for unit ranges.</p> <pre><code>@chain df begin\n@slice(1:2:7)\nend\n</code></pre> 4\u00d73 DataFrame Rowrow_numabInt64StringInt6411a123b135c247d3 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/slice/#separate-multiple-row-selections-with-commas","title":"Separate multiple row selections with commas","text":"<p>If you have multiple different row selections, you can separate them with commas.</p> <pre><code>@chain df begin\n@slice(1:5, 10)\nend\n</code></pre> 6\u00d73 DataFrame Rowrow_numabInt64StringInt6411a122a133b144b255c2610e4 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/slice/#use-n-as-short-hand-to-indicate-the-number-of-rows","title":"Use <code>n()</code> as short-hand to indicate the number of rows","text":"<p>Select the last 2 rows.</p> <pre><code>@chain df begin\n@slice(n()-1, n())\nend\n</code></pre> 2\u00d73 DataFrame Rowrow_numabInt64StringInt6419e3210e4 <p>You can even use <code>n()</code> inside of UnitRanges, just like in R. Notice that the order of operations is slightly different in Julia as compared to R, so you don't have to wrap the <code>n()-1</code> expression inside of parentheses.</p> <pre><code>@chain df begin\n@slice(n()-1:n())\nend\n</code></pre> 2\u00d73 DataFrame Rowrow_numabInt64StringInt6419e3210e4 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/slice/#inverted-selection-using-negative-numbers","title":"Inverted selection using negative numbers","text":"<p>This line selects all rows except the first 5 rows.</p> <pre><code>@chain df begin\n@slice(-(1:5))\nend\n</code></pre> 5\u00d73 DataFrame Rowrow_numabInt64StringInt6416c227d338d349e3510e4 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/summarize/","title":"@summarize","text":"<p>Summarizing a dataset involves aggregating multiple rows down to (usually) a single row of data. This can be performed across the entire dataset, or if the dataset is grouped, then for each row in the dataset. This is implemented similarly to R's tidyverse using <code>@summarize()</code>. Out of admiration for Hadley Wickham, and to be consistent with the R <code>tidyverse</code>, both <code>@summarize()</code> and <code>@summarise()</code> are supported.</p> <p>Note that summarization is different from other verbs in the <code>Tidier.jl</code> in 2 respects:</p> <ol> <li>No auto-vectorization is performed when using <code>@summarize()</code></li> <li>One layer of grouping is removed after each <code>@summarize()</code> function.</li> </ol> <p>If you require further changes to grouping beyond the defaults, you can either <code>@ungroup()</code> or call <code>@group_by()</code> to regroup by a different set of variables.</p> <pre><code>using Tidier\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/summarize/#using-summarize-with-n-to-count-the-number-of-movies-in-the-dataset","title":"Using <code>@summarize()</code> with <code>n()</code> to count the number of movies in the dataset.","text":"<p>Within the context of <code>@summarize()</code> only, <code>n()</code> is converted to DataFrames.jl's <code>nrow()</code> function.</p> <pre><code>@chain movies begin\n@summarize(n = n())\nend\n</code></pre> 1\u00d71 DataFrame RownInt64158788 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/summarize/#using-summarize-to-calculate-average-budget-of-movies-in-the-dataset","title":"Using <code>@summarize()</code> to calculate average budget of movies in the dataset.","text":"<p>The median budget in this dataset is 3 million, and the mean budget is 13 million! Making movies must be way more lucrative than making Julia packages.</p> <pre><code>@chain movies begin\n@mutate(Budget = Budget / 1_000_000)\n@summarize(median_budget = median(skipmissing(Budget)),\nmean_budget = mean(skipmissing(Budget)))\nend\n</code></pre> 1\u00d72 DataFrame Rowmedian_budgetmean_budgetFloat64Float6413.013.4125 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/summarize/#combining-group_by-with-summarise","title":"Combining <code>@group_by()</code> with <code>@summarise()</code>","text":"<p>How many movies came out in each of the last 5 years?</p> <pre><code>@chain movies begin\n@group_by(Year)\n@summarise(n = n())\n@arrange(desc(Year))\n@slice(1:5)\nend\n</code></pre> 5\u00d72 DataFrame RowYearnInt32Int6412005349220041945320032158420022168520012121 <p>Notice that there was no need to explicitly <code>@ungroup()</code> the dataset after summarizing here. The <code>@summarise()</code> function removed one layer of grouping. Since this dataset was only grouped by one variable (<code>Year</code>), it was no longer grouped after the <code>@summarise</code> was performed.</p> <p>This page was generated using Literate.jl.</p>"}]}